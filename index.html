<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>3Dåœ£è¯æ ‘ - æ‰‹åŠ¿æ§åˆ¶ç‰ˆ</title>
    
    <!-- å¼•å…¥Three.jså’Œç›¸å…³åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/environments/RoomEnvironment.js"></script>
    
    <!-- å¼•å…¥MediaPipe Hand Landmarker -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.js"></script>

    <style>
        :root {
            --safe-area-inset-top: env(safe-area-inset-top, 0px);
            --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            box-sizing: border-box;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
            position: fixed;
            width: 100vw;
            height: 100vh;
            touch-action: none;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            margin-top: calc(env(safe-area-inset-top) * -1);
            margin-bottom: calc(env(safe-area-inset-bottom) * -1);
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* åŠ è½½ç•Œé¢ */
        #loader {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100vw; 
            height: 100vh;
            background: #000; 
            z-index: 100;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            transition: opacity 0.8s ease-out;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .loader-text {
            color: #d4af37; 
            font-size: 14px; 
            letter-spacing: 2px; 
            margin-top: 20px;
            text-transform: uppercase; 
            font-weight: 300;
            text-align: center;
            padding: 0 20px;
        }
        
        .spinner {
            width: 30px; 
            height: 30px; 
            border: 1px solid rgba(212, 175, 55, 0.2); 
            border-top: 1px solid #d4af37; 
            border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        
        /* æ‰‹åŠ¿æ§åˆ¶ç•Œé¢ */
        .gesture-controls {
            position: fixed;
            top: calc(15px + env(safe-area-inset-top));
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(212, 175, 55, 0.4);
            border-radius: 12px;
            padding: 12px;
            z-index: 20;
            backdrop-filter: blur(10px);
            color: #d4af37;
            max-width: 300px;
        }
        
        .gesture-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .gesture-list {
            font-size: 11px;
            line-height: 1.5;
            color: rgba(212, 175, 55, 0.8);
        }
        
        .gesture-item {
            margin: 4px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .gesture-icon {
            font-size: 12px;
            width: 16px;
            text-align: center;
        }
        
        /* æ‘„åƒå¤´ç•Œé¢ */
        .camera-container {
            position: fixed;
            bottom: calc(15px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 90px;
            border-radius: 8px;
            overflow: hidden;
            z-index: 15;
            border: 2px solid rgba(212, 175, 55, 0.3);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
            transition: all 0.3s ease;
        }
        
        .camera-container.active {
            border-color: #d4af37;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.4);
        }
        
        #camera-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
        }
        
        #camera-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-indicator {
            position: fixed;
            top: calc(15px + env(safe-area-inset-top));
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: #d4af37;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
        
        .status-icon {
            font-size: 14px;
        }
        
        .hand-status {
            position: fixed;
            bottom: calc(110px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #d4af37;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 20;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.3);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            position: fixed;
            bottom: calc(15px + env(safe-area-inset-bottom));
            left: 15px;
            display: flex;
            gap: 10px;
            z-index: 20;
        }
        
        .control-btn {
            background: rgba(30, 30, 30, 0.7);
            border: 1px solid rgba(212, 175, 55, 0.4);
            color: #d4af37;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            touch-action: manipulation;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .control-btn:active {
            background: rgba(212, 175, 55, 0.3);
            transform: scale(0.95);
        }
        
        .control-btn.active {
            background: rgba(212, 175, 55, 0.2);
            border-color: #d4af37;
        }
        
        /* æç¤ºä¿¡æ¯ */
        .hint-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #d4af37;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            z-index: 25;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(212, 175, 55, 0.3);
            max-width: 80%;
            animation: fadeInOut 3s ease forwards;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* ç›¸æœºæƒé™æç¤º */
        .permission-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
        }
        
        .permission-content {
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #d4af37;
            border-radius: 15px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
        }
        
        .permission-title {
            color: #d4af37;
            font-size: 20px;
            margin-bottom: 15px;
        }
        
        .permission-text {
            color: #aaa;
            font-size: 14px;
            margin-bottom: 25px;
            line-height: 1.5;
        }
        
        .permission-btn {
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid #d4af37;
            color: #d4af37;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            width: 100%;
        }
        
        .permission-btn:active {
            background: rgba(212, 175, 55, 0.4);
        }
        
        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            .gesture-controls {
                max-width: 250px;
                font-size: 10px;
            }
            
            .gesture-list {
                font-size: 10px;
            }
            
            .camera-container {
                width: 100px;
                height: 75px;
            }
            
            .control-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
        }
        
        @media (max-height: 700px) {
            .gesture-controls {
                top: 10px;
                left: 10px;
                padding: 8px;
            }
            
            .camera-container {
                bottom: 10px;
                width: 90px;
                height: 68px;
            }
            
            .hand-status {
                bottom: 85px;
            }
            
            .control-panel {
                bottom: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">åˆå§‹åŒ–æ‰‹åŠ¿æ§åˆ¶...</div>
    </div>
    
    <!-- ç›¸æœºæƒé™æç¤º -->
    <div class="permission-overlay" id="permission-overlay">
        <div class="permission-content">
            <div class="permission-title">éœ€è¦ç›¸æœºæƒé™</div>
            <div class="permission-text">
                ä¸ºäº†ä½¿ç”¨æ‰‹åŠ¿æ§åˆ¶åŠŸèƒ½ï¼Œéœ€è¦è®¿é—®æ‚¨çš„æ‘„åƒå¤´ã€‚<br>
                æ‘„åƒå¤´ä»…ç”¨äºæ‰‹åŠ¿è¯†åˆ«ï¼Œä¸ä¼šä¿å­˜æˆ–ä¸Šä¼ ä»»ä½•å›¾åƒæ•°æ®ã€‚
            </div>
            <button class="permission-btn" id="enable-camera">å¯ç”¨ç›¸æœº</button>
            <button class="permission-btn" onclick="continueWithoutCamera()" style="background: rgba(255,255,255,0.1); margin-top: 10px;">
                è·³è¿‡æ‰‹åŠ¿æ§åˆ¶
            </button>
        </div>
    </div>

    <div id="canvas-container"></div>
    
    <!-- æ‰‹åŠ¿æ§åˆ¶è¯´æ˜ -->
    <div class="gesture-controls">
        <div class="gesture-title">
            <span>ğŸ‘‹</span>
            <span>æ‰‹åŠ¿æ§åˆ¶æŒ‡å—</span>
        </div>
        <div class="gesture-list">
            <div class="gesture-item">
                <span class="gesture-icon">âœŠ</span>
                <span>æ¡æ‹³ - å›åˆ°åœ£è¯æ ‘å½¢æ€</span>
            </div>
            <div class="gesture-item">
                <span class="gesture-icon">ğŸ–ï¸</span>
                <span>å¼ å¼€æ‰‹ - è¿›å…¥æ•£å¼€å½¢æ€</span>
            </div>
            <div class="gesture-item">
                <span class="gesture-icon">ğŸ¤</span>
                <span>æŠ“å– - æ”¾å¤§ç…§ç‰‡</span>
            </div>
            <div class="gesture-item">
                <span class="gesture-icon">ğŸ”„</span>
                <span>æ‰‹æ—‹è½¬ - æ—‹è½¬åœºæ™¯</span>
            </div>
        </div>
    </div>
    
    <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
    <div class="status-indicator" id="status-indicator">
        <span class="status-icon">ğŸ„</span>
        <span id="mode-text">åœ£è¯æ ‘å½¢æ€</span>
    </div>
    
    <!-- æ‘„åƒå¤´é¢„è§ˆ -->
    <div class="camera-container" id="camera-container">
        <video id="camera-video" autoplay playsinline></video>
        <canvas id="camera-canvas"></canvas>
    </div>
    
    <!-- æ‰‹åŠ¿çŠ¶æ€ -->
    <div class="hand-status" id="hand-status">
        <span>ğŸ‘‹</span>
        <span id="hand-text">ç­‰å¾…æ‰‹åŠ¿...</span>
    </div>
    
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <div class="control-btn" id="btn-tree" title="åœ£è¯æ ‘å½¢æ€">ğŸ„</div>
        <div class="control-btn" id="btn-scatter" title="æ•£å¼€å½¢æ€">âœ¨</div>
        <div class="control-btn" id="btn-camera" title="åˆ‡æ¢æ‘„åƒå¤´">ğŸ“·</div>
    </div>
    
    <!-- æç¤ºä¿¡æ¯å®¹å™¨ -->
    <div id="hint-container"></div>

    <script>
        // æ£€æµ‹è®¾å¤‡ç±»å‹
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIPhone = /iPhone/i.test(navigator.userAgent);
        
        // é…ç½®
        const CONFIG = {
            colors: {
                bg: 0x000000, 
                champagneGold: 0xffd966, 
                deepGreen: 0x03180a,     
                accentRed: 0x990000,     
            },
            particles: {
                count: isMobile ? 300 : 600,
                dustCount: isMobile ? 600 : 1200,
                treeHeight: 16,  
                treeRadius: 4    
            },
            camera: {
                z: isMobile ? 22 : 35
            },
            gesture: {
                // æ‰‹åŠ¿è¯†åˆ«é˜ˆå€¼
                fistThreshold: 0.15,      // æ¡æ‹³é˜ˆå€¼
                openHandThreshold: 0.25,  // å¼ å¼€æ‰‹é˜ˆå€¼
                pinchThreshold: 0.06,     // æŠ“å–é˜ˆå€¼
                rotationSensitivity: 2.0, // æ—‹è½¬çµæ•åº¦
                smoothFactor: 0.3         // å¹³æ»‘ç³»æ•°
            }
        };

        // åº”ç”¨çŠ¶æ€
        const STATE = {
            mode: 'TREE', // TREE, SCATTER, FOCUS
            focusTarget: null,
            transitionProgress: 0,
            
            // æ‰‹åŠ¿çŠ¶æ€
            hand: {
                detected: false,
                landmarks: null,
                position: { x: 0, y: 0 },
                gesture: 'NONE', // NONE, FIST, OPEN, PINCH, ROTATE
                rotation: { x: 0, y: 0 },
                pinchStrength: 0,
                history: []
            },
            
            // ç›¸æœºæ§åˆ¶
            rotation: { x: 0, y: 0 },
            autoRotate: true,
            
            // ç³»ç»ŸçŠ¶æ€
            cameraEnabled: false,
            handDetector: null,
            videoStream: null
        };

        // Three.jså˜é‡
        let scene, camera, renderer, composer;
        let mainGroup; 
        let clock = new THREE.Clock();
        let particleSystem = []; 
        let photoMeshGroup = new THREE.Group();
        let caneTexture;

        // MediaPipeå˜é‡
        let handLandmarker;
        let videoElement, canvasElement, canvasCtx;
        let lastVideoTime = -1;

        // åˆå§‹åŒ–å‡½æ•°
        async function init() {
            try {
                initThree();
                setupEnvironment();
                setupLights();
                createTextures();
                createParticles();
                createDust();
                createDefaultPhotos();
                setupPostProcessing();
                setupUIEvents();
                
                // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
                await initHandDetection();
                
                // éšè—åŠ è½½ç•Œé¢
                const loader = document.getElementById('loader');
                if (loader) {
                    setTimeout(() => {
                        loader.style.opacity = 0;
                        setTimeout(() => {
                            loader.style.display = 'none';
                        }, 800);
                    }, 1000);
                }

                updateStatusIndicator();
                animate();
            } catch (error) {
                console.error('åˆå§‹åŒ–é”™è¯¯:', error);
                showHint('åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 'error');
            }
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, CONFIG.camera.z);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: false, 
                powerPreference: "high-performance",
                precision: 'mediump'
            });
            
            renderer.setPixelRatio(isMobile ? 2 : 1.5);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.8;
            renderer.shadowMap.enabled = false;
            container.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }

        function setupEnvironment() {
            try {
                if (typeof THREE.RoomEnvironment !== 'undefined') {
                    const pmremGenerator = new THREE.PMREMGenerator(renderer);
                    scene.environment = pmremGenerator.fromScene(new THREE.RoomEnvironment(), 0.04).texture;
                }
            } catch (error) {
                console.warn('ç¯å¢ƒè®¾ç½®å¤±è´¥:', error);
            }
            
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
        }

        function setupLights() {
            const innerLight = new THREE.PointLight(0xffaa00, 1.0, 10);
            innerLight.position.set(0, 4, 0);
            mainGroup.add(innerLight);

            const spotGold = new THREE.SpotLight(0xffcc66, 400);
            spotGold.position.set(10, 20, 20);
            spotGold.angle = 0.3;
            spotGold.penumbra = 0.5;
            scene.add(spotGold);
        }

        function setupPostProcessing() {
            if (isMobile || typeof THREE.EffectComposer === 'undefined') return;
            
            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight), 
                    0.8, 0.4, 0.8
                );

                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
            } catch (error) {
                console.warn('åæœŸå¤„ç†è®¾ç½®å¤±è´¥:', error);
            }
        }

        function createTextures() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0,0,32,32);
            ctx.fillStyle = '#880000'; 
            ctx.beginPath();
            for(let i=-32; i<64; i+=8) {
                ctx.moveTo(i, 0); 
                ctx.lineTo(i+8, 32); 
                ctx.lineTo(i+4, 32); 
                ctx.lineTo(i-4, 0);
            }
            ctx.fill();
            caneTexture = new THREE.CanvasTexture(canvas);
            caneTexture.wrapS = THREE.RepeatWrapping;
            caneTexture.wrapT = THREE.RepeatWrapping;
            caneTexture.repeat.set(1, 1);
        }

        class Particle {
            constructor(mesh, type, isDust = false) {
                this.mesh = mesh;
                this.type = type;
                this.isDust = isDust;
                
                this.posTree = new THREE.Vector3();
                this.posScatter = new THREE.Vector3();
                this.posFocus = new THREE.Vector3();
                this.baseScale = mesh.scale.x;

                this.spinSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * (type === 'PHOTO' ? 0.1 : 0.8),
                    (Math.random() - 0.5) * (type === 'PHOTO' ? 0.1 : 0.8),
                    (Math.random() - 0.5) * (type === 'PHOTO' ? 0.1 : 0.8)
                );

                this.calculatePositions();
            }

            calculatePositions() {
                // åœ£è¯æ ‘ä½ç½®
                const h = CONFIG.particles.treeHeight;
                const halfH = h / 2;
                let t = Math.random(); 
                t = Math.pow(t, 0.8); 
                const y = (t * h) - halfH;
                let rMax = CONFIG.particles.treeRadius * (1.0 - t); 
                if (rMax < 0.2) rMax = 0.2;
                const angle = t * 25 * Math.PI + Math.random() * Math.PI; 
                const r = rMax * (0.8 + Math.random() * 0.4); 
                this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);

                // æ•£å¼€ä½ç½®
                let rScatter = this.isDust ? (3 + Math.random()*6) : (2 + Math.random()*4);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(
                    rScatter * Math.sin(phi) * Math.cos(theta),
                    rScatter * Math.sin(phi) * Math.sin(theta),
                    rScatter * Math.cos(phi)
                );

                // ç„¦ç‚¹ä½ç½®
                const focusAngle = Math.random() * Math.PI * 2;
                const focusRadius = 15;
                this.posFocus.set(
                    Math.cos(focusAngle) * focusRadius,
                    (Math.random() - 0.5) * 8,
                    Math.sin(focusAngle) * focusRadius
                );
            }

            update(dt, mode, focusTargetMesh) {
                let targetPos = this.posTree;
                let targetScale = this.baseScale;
                let shouldLookAtCamera = false;

                if (mode === 'SCATTER') {
                    targetPos = this.posScatter;
                    targetScale = this.baseScale * 1.2;
                    
                    // åœ¨æ•£å¼€çŠ¶æ€ä¸‹æ·»åŠ æ—‹è½¬
                    this.mesh.rotation.x += this.spinSpeed.x * dt;
                    this.mesh.rotation.y += this.spinSpeed.y * dt;
                    this.mesh.rotation.z += this.spinSpeed.z * dt;
                } else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        targetPos = new THREE.Vector3(0, 1, 10);
                        targetScale = this.baseScale * 4;
                        shouldLookAtCamera = true;
                    } else {
                        targetPos = this.posFocus;
                        targetScale = this.baseScale * 0.3;
                    }
                } else {
                    // TREE æ¨¡å¼
                    this.mesh.rotation.y += 0.1 * dt;
                }

                // å¹³æ»‘è¿‡æ¸¡
                const lerpSpeed = mode === 'FOCUS' && this.mesh === focusTargetMesh ? 5.0 : 2.0;
                this.mesh.position.lerp(targetPos, lerpSpeed * dt);
                this.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), lerpSpeed * dt);

                if (shouldLookAtCamera) {
                    this.mesh.lookAt(camera.position);
                }

                // ç°å°˜ç²’å­åœ¨åœ£è¯æ ‘æ¨¡å¼ä¸‹éšè—
                if (this.isDust && mode === 'TREE') {
                    this.mesh.visible = false;
                } else if (this.isDust) {
                    this.mesh.visible = true;
                    // ç°å°˜çš„è„‰åŠ¨æ•ˆæœ
                    const pulseScale = 0.8 + 0.4 * Math.sin(clock.elapsedTime * 3 + this.mesh.id);
                    this.mesh.scale.multiplyScalar(pulseScale);
                }
            }
        }

        function createParticles() {
            const sphereGeo = new THREE.SphereGeometry(0.25, 8, 8);
            const boxGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            
            const goldMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.champagneGold,
                metalness: 0.6,
                roughness: 0.5
            });

            const greenMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.deepGreen,
                roughness: 0.9
            });

            const redMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.accentRed,
                roughness: 0.6
            });
            
            const candyMat = new THREE.MeshStandardMaterial({ 
                map: caneTexture,
                roughness: 0.8
            });

            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random();
                let mesh, type;
                
                if (rand < 0.40) {
                    mesh = new THREE.Mesh(boxGeo, greenMat);
                    type = 'BOX';
                } else if (rand < 0.70) {
                    mesh = new THREE.Mesh(boxGeo, goldMat);
                    type = 'GOLD_BOX';
                } else if (rand < 0.90) {
                    mesh = new THREE.Mesh(sphereGeo, goldMat);
                    type = 'GOLD_SPHERE';
                } else if (rand < 0.95) {
                    mesh = new THREE.Mesh(sphereGeo, redMat);
                    type = 'RED';
                } else {
                    mesh = new THREE.Mesh(sphereGeo, candyMat);
                    type = 'CANDY';
                }

                const s = 0.15 + Math.random() * 0.25;
                mesh.scale.set(s, s, s);
                mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);
                
                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, type, false));
            }

            // æ·»åŠ æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(0.6, 0);
            const starMat = new THREE.MeshStandardMaterial({
                color: 0xffdd88,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.particles.treeHeight / 2 + 0.5, 0);
            mainGroup.add(star);
            
            mainGroup.add(photoMeshGroup);
        }

        function createDust() {
            const geo = new THREE.TetrahedronGeometry(0.03, 0);
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0xffeebb,
                transparent: true,
                opacity: 0.3
            });
            
            for(let i = 0; i < CONFIG.particles.dustCount; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.scale.setScalar(0.15 + Math.random());
                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, 'DUST', true));
            }
        }

        function createDefaultPhotos() {
            const defaultPhotos = [
                { text: "åœ£è¯\nå¿«ä¹", color: "#d4af37" },
                { text: "å¹³å®‰\nå–œä¹", color: "#ff6b6b" },
                { text: "å¿ƒæƒ³\näº‹æˆ", color: "#4ecdc4" }
            ];
            
            defaultPhotos.forEach((photo, index) => {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // èƒŒæ™¯
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, 256, 256);
                
                // è¾¹æ¡†
                ctx.strokeStyle = photo.color;
                ctx.lineWidth = 6;
                ctx.strokeRect(10, 10, 236, 236);
                
                // æ–‡å­—
                ctx.fillStyle = photo.color;
                ctx.font = 'bold 32px "Microsoft YaHei", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const lines = photo.text.split('\n');
                lines.forEach((line, i) => {
                    ctx.fillText(line, 128, 128 - 20 + (i * 40));
                });
                
                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                addPhotoToScene(tex);
            });
        }

        function addPhotoToScene(texture) {
            const frameGeo = new THREE.BoxGeometry(0.9, 1.2, 0.02);
            const frameMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.champagneGold,
                metalness: 0.6,
                roughness: 0.5
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);

            const photoGeo = new THREE.PlaneGeometry(0.8, 1.1);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.015;

            const group = new THREE.Group();
            group.add(frame);
            group.add(photo);
            
            const s = 0.4;
            group.scale.set(s, s, s);
            
            photoMeshGroup.add(group);
            particleSystem.push(new Particle(group, 'PHOTO', false));
        }

        // æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–
        async function initHandDetection() {
            try {
                videoElement = document.getElementById('camera-video');
                canvasElement = document.getElementById('camera-canvas');
                canvasCtx = canvasElement.getContext('2d');
                
                // è®¾ç½®canvaså°ºå¯¸
                canvasElement.width = 120;
                canvasElement.height = 90;
                
                // è¯·æ±‚ç›¸æœºæƒé™
                await requestCameraPermission();
                
                // åˆå§‹åŒ–MediaPipe Hand Landmarker
                const vision = await window.FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                handLandmarker = await window.HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                
                // å¼€å§‹è§†é¢‘æµå¤„ç†
                startVideoProcessing();
                
                showHint('æ‰‹åŠ¿è¯†åˆ«å·²å¯ç”¨ï¼', 'success');
                updateHandStatus('ç­‰å¾…æ‰‹åŠ¿...');
                
            } catch (error) {
                console.error('æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥:', error);
                showHint('æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·ç¡®ä¿å·²æˆäºˆç›¸æœºæƒé™', 'error');
                updateHandStatus('æ‰‹åŠ¿è¯†åˆ«æœªå¯ç”¨');
            }
        }

        async function requestCameraPermission() {
            return new Promise((resolve, reject) => {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    showPermissionOverlay();
                    reject(new Error('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®'));
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰æƒé™
                navigator.permissions.query({ name: 'camera' }).then(permissionStatus => {
                    if (permissionStatus.state === 'granted') {
                        startCamera();
                        resolve();
                    } else if (permissionStatus.state === 'prompt') {
                        startCamera();
                        resolve();
                    } else {
                        showPermissionOverlay();
                        reject(new Error('æ‘„åƒå¤´æƒé™è¢«æ‹’ç»'));
                    }
                }).catch(() => {
                    // æŸäº›æµè§ˆå™¨ä¸æ”¯æŒpermissions API
                    startCamera();
                    resolve();
                });
            });
        }

        function startCamera() {
            const constraints = {
                video: {
                    facingMode: 'user',
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    frameRate: { ideal: 30 }
                }
            };
            
            navigator.mediaDevices.getUserMedia(constraints)
                .then(stream => {
                    STATE.videoStream = stream;
                    videoElement.srcObject = stream;
                    STATE.cameraEnabled = true;
                    
                    document.getElementById('camera-container').classList.add('active');
                    hidePermissionOverlay();
                    
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                    };
                })
                .catch(error => {
                    console.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥:', error);
                    showPermissionOverlay();
                });
        }

        function startVideoProcessing() {
            function processFrame() {
                if (!STATE.cameraEnabled || !handLandmarker || videoElement.readyState < 2) {
                    requestAnimationFrame(processFrame);
                    return;
                }
                
                const startTimeMs = performance.now();
                
                if (lastVideoTime !== videoElement.currentTime) {
                    lastVideoTime = videoElement.currentTime;
                    
                    // æ£€æµ‹æ‰‹åŠ¿
                    const results = handLandmarker.detectForVideo(videoElement, startTimeMs);
                    processHandResults(results);
                    
                    // åœ¨canvasä¸Šç»˜åˆ¶ç»“æœ
                    drawHandLandmarks(results);
                }
                
                requestAnimationFrame(processFrame);
            }
            
            processFrame();
        }

        function processHandResults(results) {
            if (!results || !results.landmarks || results.landmarks.length === 0) {
                STATE.hand.detected = false;
                STATE.hand.gesture = 'NONE';
                updateHandStatus('æœªæ£€æµ‹åˆ°æ‰‹éƒ¨');
                return;
            }
            
            STATE.hand.detected = true;
            const landmarks = results.landmarks[0];
            STATE.hand.landmarks = landmarks;
            
            // è®¡ç®—æ‰‹åŠ¿
            const gesture = recognizeGesture(landmarks);
            STATE.hand.gesture = gesture;
            
            // æ›´æ–°æ‰‹åŠ¿çŠ¶æ€æ˜¾ç¤º
            updateHandStatus(getGestureText(gesture));
            
            // æ ¹æ®æ‰‹åŠ¿æ›´æ–°åº”ç”¨çŠ¶æ€
            handleGesture(gesture, landmarks);
        }

        function recognizeGesture(landmarks) {
            // è·å–å…³é”®ç‚¹
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const thumbBase = landmarks[2];
            const indexBase = landmarks[5];
            const middleBase = landmarks[9];
            const ringBase = landmarks[13];
            const pinkyBase = landmarks[17];
            
            // è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»
            const distanceToWrist = (tip) => {
                return Math.sqrt(
                    Math.pow(tip.x - wrist.x, 2) + 
                    Math.pow(tip.y - wrist.y, 2)
                );
            };
            
            // è®¡ç®—æŠ“å–å¼ºåº¦ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡çš„è·ç¦»ï¼‰
            const pinchDistance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );
            STATE.hand.pinchStrength = 1 - Math.min(pinchDistance * 10, 1);
            
            // è®¡ç®—æ‰‹çš„å¼€æ”¾ç¨‹åº¦ï¼ˆæ‰€æœ‰æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»ï¼‰
            const avgDistance = (
                distanceToWrist(thumbTip) +
                distanceToWrist(indexTip) +
                distanceToWrist(middleTip) +
                distanceToWrist(ringTip) +
                distanceToWrist(pinkyTip)
            ) / 5;
            
            // æ£€æµ‹æ¡æ‹³ï¼ˆæŒ‡å°–é è¿‘æ‰‹æŒï¼‰
            const isFist = avgDistance < CONFIG.gesture.fistThreshold;
            
            // æ£€æµ‹å¼ å¼€æ‰‹
            const isOpen = avgDistance > CONFIG.gesture.openHandThreshold;
            
            // æ£€æµ‹æŠ“å–
            const isPinch = pinchDistance < CONFIG.gesture.pinchThreshold;
            
            // æ£€æµ‹æ—‹è½¬ï¼ˆé€šè¿‡æ‰‹è…•ä½ç½®å˜åŒ–ï¼‰
            if (STATE.hand.position.x !== 0 && STATE.hand.position.y !== 0) {
                const deltaX = wrist.x - STATE.hand.position.x;
                const deltaY = wrist.y - STATE.hand.position.y;
                
                if (Math.abs(deltaX) > 0.01 || Math.abs(deltaY) > 0.01) {
                    STATE.hand.rotation.x += deltaY * CONFIG.gesture.rotationSensitivity;
                    STATE.hand.rotation.y += deltaX * CONFIG.gesture.rotationSensitivity;
                }
            }
            
            // æ›´æ–°æ‰‹çš„ä½ç½®
            STATE.hand.position.x = wrist.x;
            STATE.hand.position.y = wrist.y;
            
            // ç¡®å®šæ‰‹åŠ¿
            if (isFist) return 'FIST';
            if (isOpen) return 'OPEN';
            if (isPinch) return 'PINCH';
            if (Math.abs(STATE.hand.rotation.x) > 0.05 || Math.abs(STATE.hand.rotation.y) > 0.05) return 'ROTATE';
            
            return 'NONE';
        }

        function handleGesture(gesture, landmarks) {
            switch (gesture) {
                case 'FIST':
                    // æ¡æ‹³ï¼šå›åˆ°åœ£è¯æ ‘å½¢æ€
                    if (STATE.mode !== 'TREE') {
                        STATE.mode = 'TREE';
                        STATE.focusTarget = null;
                        STATE.autoRotate = true;
                        updateStatusIndicator();
                        showHint('å›åˆ°åœ£è¯æ ‘å½¢æ€', 'info');
                    }
                    break;
                    
                case 'OPEN':
                    // å¼ å¼€æ‰‹ï¼šè¿›å…¥æ•£å¼€å½¢æ€
                    if (STATE.mode !== 'SCATTER') {
                        STATE.mode = 'SCATTER';
                        STATE.focusTarget = null;
                        STATE.autoRotate = false;
                        updateStatusIndicator();
                        showHint('è¿›å…¥æ•£å¼€å½¢æ€', 'info');
                    }
                    break;
                    
                case 'PINCH':
                    // æŠ“å–ï¼šæ”¾å¤§ç…§ç‰‡
                    if (STATE.mode === 'SCATTER' && !STATE.focusTarget) {
                        const photos = particleSystem.filter(p => p.type === 'PHOTO');
                        if (photos.length > 0) {
                            STATE.mode = 'FOCUS';
                            const randomIndex = Math.floor(Math.random() * photos.length);
                            STATE.focusTarget = photos[randomIndex].mesh;
                            updateStatusIndicator();
                            showHint('æ”¾å¤§ç…§ç‰‡', 'info');
                        }
                    }
                    break;
                    
                case 'ROTATE':
                    // æ—‹è½¬ï¼šæ§åˆ¶åœºæ™¯æ—‹è½¬
                    STATE.autoRotate = false;
                    const smoothFactor = CONFIG.gesture.smoothFactor;
                    STATE.rotation.x += (STATE.hand.rotation.x - STATE.rotation.x) * smoothFactor;
                    STATE.rotation.y += (STATE.hand.rotation.y - STATE.rotation.y) * smoothFactor;
                    
                    // é™åˆ¶æ—‹è½¬è§’åº¦
                    STATE.rotation.x = Math.max(-1, Math.min(1, STATE.rotation.x));
                    STATE.rotation.y = Math.max(-1, Math.min(1, STATE.rotation.y));
                    break;
            }
            
            // é‡ç½®æ—‹è½¬å€¼
            STATE.hand.rotation.x *= 0.9;
            STATE.hand.rotation.y *= 0.9;
        }

        function drawHandLandmarks(results) {
            if (!results.landmarks || results.landmarks.length === 0) {
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                return;
            }
            
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.save();
            
            // é•œåƒç¿»è½¬canvas
            canvasCtx.scale(-1, 1);
            canvasCtx.translate(-canvasElement.width, 0);
            
            // ç»˜åˆ¶è§†é¢‘å¸§
            canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
            
            // ç»˜åˆ¶æ‰‹åŠ¿è¯†åˆ«ç»“æœ
            const landmarks = results.landmarks[0];
            const connections = window.HAND_CONNECTIONS || [];
            
            // ç»˜åˆ¶è¿æ¥çº¿
            canvasCtx.strokeStyle = '#00ff00';
            canvasCtx.lineWidth = 2;
            
            connections.forEach(connection => {
                const [start, end] = connection;
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                canvasCtx.beginPath();
                canvasCtx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
                canvasCtx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
                canvasCtx.stroke();
            });
            
            // ç»˜åˆ¶å…³é”®ç‚¹
            landmarks.forEach(landmark => {
                canvasCtx.fillStyle = '#ff0000';
                canvasCtx.beginPath();
                canvasCtx.arc(
                    landmark.x * canvasElement.width,
                    landmark.y * canvasElement.height,
                    3, 0, Math.PI * 2
                );
                canvasCtx.fill();
            });
            
            canvasCtx.restore();
            
            // ç»˜åˆ¶æ‰‹åŠ¿çŠ¶æ€
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            canvasCtx.fillRect(0, 0, canvasElement.width, 18);
            canvasCtx.fillStyle = '#ffffff';
            canvasCtx.font = '10px Arial';
            canvasCtx.textAlign = 'center';
            canvasCtx.fillText(getGestureText(STATE.hand.gesture), canvasElement.width / 2, 12);
        }

        function getGestureText(gesture) {
            switch (gesture) {
                case 'FIST': return 'âœŠ æ¡æ‹³';
                case 'OPEN': return 'ğŸ–ï¸ å¼ å¼€';
                case 'PINCH': return 'ğŸ¤ æŠ“å–';
                case 'ROTATE': return 'ğŸ”„ æ—‹è½¬';
                default: return 'ğŸ‘‹ ç­‰å¾…æ‰‹åŠ¿';
            }
        }

        function updateHandStatus(text) {
            const handStatus = document.getElementById('hand-status');
            const handText = document.getElementById('hand-text');
            
            if (handStatus && handText) {
                handText.textContent = text;
                
                if (!STATE.cameraEnabled) {
                    handStatus.style.opacity = '0.5';
                } else if (STATE.hand.detected) {
                    handStatus.style.opacity = '1';
                    handStatus.style.borderColor = 'rgba(212, 175, 55, 0.6)';
                } else {
                    handStatus.style.opacity = '0.7';
                }
            }
        }

        function updateStatusIndicator() {
            const indicator = document.getElementById('status-indicator');
            const modeText = document.getElementById('mode-text');
            const icon = indicator?.querySelector('.status-icon');
            
            if (indicator && modeText && icon) {
                switch (STATE.mode) {
                    case 'TREE':
                        modeText.textContent = 'åœ£è¯æ ‘å½¢æ€';
                        icon.textContent = 'ğŸ„';
                        indicator.style.borderColor = 'rgba(34, 139, 34, 0.6)';
                        break;
                    case 'SCATTER':
                        modeText.textContent = 'æ•£å¼€å½¢æ€';
                        icon.textContent = 'âœ¨';
                        indicator.style.borderColor = 'rgba(212, 175, 55, 0.6)';
                        break;
                    case 'FOCUS':
                        modeText.textContent = 'ç…§ç‰‡æ”¾å¤§';
                        icon.textContent = 'ğŸ“¸';
                        indicator.style.borderColor = 'rgba(66, 133, 244, 0.6)';
                        break;
                }
            }
        }

        function showHint(text, type = 'info') {
            const container = document.getElementById('hint-container');
            if (!container) return;
            
            const hint = document.createElement('div');
            hint.className = 'hint-overlay';
            hint.textContent = text;
            
            // è®¾ç½®é¢œè‰²
            if (type === 'error') {
                hint.style.color = '#ff6b6b';
                hint.style.borderColor = 'rgba(255, 107, 107, 0.3)';
            } else if (type === 'success') {
                hint.style.color = '#4ecdc4';
                hint.style.borderColor = 'rgba(78, 205, 196, 0.3)';
            }
            
            container.appendChild(hint);
            
            // 3ç§’åç§»é™¤æç¤º
            setTimeout(() => {
                hint.remove();
            }, 3000);
        }

        function showPermissionOverlay() {
            document.getElementById('permission-overlay').style.display = 'flex';
        }

        function hidePermissionOverlay() {
            document.getElementById('permission-overlay').style.display = 'none';
        }

        function continueWithoutCamera() {
            STATE.cameraEnabled = false;
            hidePermissionOverlay();
            updateHandStatus('æ‰‹åŠ¿æ§åˆ¶å·²ç¦ç”¨');
            showHint('å·²ç¦ç”¨æ‰‹åŠ¿æ§åˆ¶ï¼Œå¯ä½¿ç”¨æŒ‰é’®æ§åˆ¶', 'info');
        }

        // UIäº‹ä»¶å¤„ç†
        function setupUIEvents() {
            // æŒ‰é’®æ§åˆ¶
            document.getElementById('btn-tree').addEventListener('click', () => {
                STATE.mode = 'TREE';
                STATE.focusTarget = null;
                STATE.autoRotate = true;
                updateStatusIndicator();
                showHint('åˆ‡æ¢åˆ°åœ£è¯æ ‘å½¢æ€', 'info');
            });
            
            document.getElementById('btn-scatter').addEventListener('click', () => {
                STATE.mode = 'SCATTER';
                STATE.focusTarget = null;
                STATE.autoRotate = false;
                updateStatusIndicator();
                showHint('åˆ‡æ¢åˆ°æ•£å¼€å½¢æ€', 'info');
            });
            
            document.getElementById('btn-camera').addEventListener('click', () => {
                if (STATE.cameraEnabled) {
                    // å…³é—­æ‘„åƒå¤´
                    if (STATE.videoStream) {
                        STATE.videoStream.getTracks().forEach(track => track.stop());
                        STATE.videoStream = null;
                    }
                    videoElement.srcObject = null;
                    STATE.cameraEnabled = false;
                    
                    document.getElementById('camera-container').classList.remove('active');
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    
                    showHint('æ‘„åƒå¤´å·²å…³é—­', 'info');
                    updateHandStatus('æ‘„åƒå¤´å·²å…³é—­');
                } else {
                    // é‡æ–°å¯ç”¨æ‘„åƒå¤´
                    requestCameraPermission().then(() => {
                        showHint('æ‘„åƒå¤´å·²å¯ç”¨', 'success');
                        updateHandStatus('ç­‰å¾…æ‰‹åŠ¿...');
                    }).catch(() => {
                        showHint('æ— æ³•å¯ç”¨æ‘„åƒå¤´', 'error');
                    });
                }
            });
            
            // å¯ç”¨ç›¸æœºæŒ‰é’®
            document.getElementById('enable-camera').addEventListener('click', () => {
                startCamera();
            });
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('orientationchange', () => {
                setTimeout(onWindowResize, 100);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.033);
            
            // è‡ªåŠ¨æ—‹è½¬ï¼ˆä»…åœ¨åœ£è¯æ ‘æ¨¡å¼ä¸‹ï¼‰
            if (STATE.autoRotate && STATE.mode === 'TREE') {
                STATE.rotation.y += 0.1 * dt;
            }
            
            // åº”ç”¨æ—‹è½¬
            mainGroup.rotation.x = STATE.rotation.x;
            mainGroup.rotation.y = STATE.rotation.y;
            
            // æ›´æ–°ç²’å­
            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));
            
            // æ¸²æŸ“
            if (composer && !isMobile) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            setTimeout(init, 100);
        });
        
        // è®¾ç½®åŠ è½½è¶…æ—¶
        setTimeout(() => {
            const loader = document.getElementById('loader');
            if (loader && loader.style.display !== 'none') {
                showHint('åŠ è½½æ—¶é—´è¿‡é•¿ï¼Œè¯·ç¡®ä¿ç½‘ç»œè¿æ¥æ­£å¸¸', 'error');
            }
        }, 10000);
    </script>
</body>
</html>