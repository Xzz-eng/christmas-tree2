<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>3Dåœ£è¯æ ‘ - åŒå¼•æ“æ‰‹åŠ¿æ§åˆ¶</title>
    
    <!-- Three.js æ ¸å¿ƒåº“ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <!-- Three.js é™„åŠ ç»„ä»¶ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <!-- æ‰‹åŠ¿è¯†åˆ«åŒå¼•æ“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/handtrackjs@latest/dist/handtrack.min.js"></script>

    <style>
        :root {
            --safe-area-inset-top: env(safe-area-inset-top, 0px);
            --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            box-sizing: border-box;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
            position: fixed;
            width: 100vw;
            height: 100vh;
            touch-action: none;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            margin-top: calc(env(safe-area-inset-top) * -1);
            margin-bottom: calc(env(safe-area-inset-bottom) * -1);
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* åŠ è½½ç•Œé¢ */
        #loader {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100vw; 
            height: 100vh;
            background: #000; 
            z-index: 100;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            transition: opacity 1s ease-out;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .loader-text {
            color: #d4af37; 
            font-size: 14px; 
            letter-spacing: 2px; 
            margin-top: 20px;
            text-transform: uppercase; 
            font-weight: 300;
            text-align: center;
            padding: 0 20px;
        }
        
        .spinner {
            width: 30px; 
            height: 30px; 
            border: 1px solid rgba(212, 175, 55, 0.2); 
            border-top: 1px solid #d4af37; 
            border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        
        /* æ‰‹åŠ¿æ§åˆ¶ç•Œé¢ */
        .gesture-controls {
            position: fixed;
            top: calc(15px + env(safe-area-inset-top));
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(212, 175, 55, 0.4);
            border-radius: 12px;
            padding: 12px;
            z-index: 20;
            backdrop-filter: blur(10px);
            color: #d4af37;
            max-width: 300px;
        }
        
        .gesture-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .gesture-list {
            font-size: 11px;
            line-height: 1.5;
            color: rgba(212, 175, 55, 0.8);
        }
        
        /* å¼•æ“çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .engine-status {
            position: fixed;
            top: calc(15px + env(safe-area-inset-top));
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: #d4af37;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 11px;
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
        
        .engine-icon {
            font-size: 12px;
        }
        
        /* æ‘„åƒå¤´ç•Œé¢ */
        .camera-container {
            position: fixed;
            bottom: calc(15px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: 140px;
            height: 105px;
            border-radius: 8px;
            overflow: hidden;
            z-index: 15;
            border: 2px solid rgba(212, 175, 55, 0.3);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
            transition: all 0.3s ease;
            background: #000;
        }
        
        .camera-container.active {
            border-color: #d4af37;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.4);
        }
        
        #camera-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
        }
        
        #camera-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* æ‰‹åŠ¿çŠ¶æ€ */
        .hand-status {
            position: fixed;
            bottom: calc(130px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #d4af37;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 20;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.3);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            position: fixed;
            bottom: calc(15px + env(safe-area-inset-bottom));
            left: 15px;
            display: flex;
            gap: 10px;
            z-index: 20;
        }
        
        .control-btn {
            background: rgba(30, 30, 30, 0.7);
            border: 1px solid rgba(212, 175, 55, 0.4);
            color: #d4af37;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            touch-action: manipulation;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .control-btn:active {
            background: rgba(212, 175, 55, 0.3);
            transform: scale(0.95);
        }
        
        .control-btn.active {
            background: rgba(212, 175, 55, 0.2);
            border-color: #d4af37;
        }
        
        /* çŠ¶æ€æç¤º */
        .status-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #d4af37;
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            z-index: 25;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(212, 175, 55, 0.3);
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        .status-hint.show {
            opacity: 1;
        }
        
        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            .gesture-controls {
                max-width: 250px;
                font-size: 10px;
            }
            
            .camera-container {
                width: 120px;
                height: 90px;
            }
            
            .control-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">åˆå§‹åŒ–åŒå¼•æ“æ‰‹åŠ¿è¯†åˆ«...</div>
    </div>
    
    <!-- çŠ¶æ€æç¤º -->
    <div class="status-hint" id="status-hint"></div>

    <div id="canvas-container"></div>
    
    <!-- æ‰‹åŠ¿æ§åˆ¶è¯´æ˜ -->
    <div class="gesture-controls">
        <div class="gesture-title">
            <span>ğŸ‘‹</span>
            <span>æ‰‹åŠ¿æ§åˆ¶æŒ‡å—</span>
        </div>
        <div class="gesture-list">
            <div>âœŠ æ¡æ‹³ â†’ åœ£è¯æ ‘å½¢æ€</div>
            <div>ğŸ–ï¸ å¼ å¼€æ‰‹ â†’ æ•£å¼€å½¢æ€</div>
            <div>ğŸ¤ æåˆ â†’ æ”¾å¤§ç…§ç‰‡</div>
            <div>ğŸ”„ æ‰‹ç§»åŠ¨ â†’ æ—‹è½¬åœºæ™¯</div>
        </div>
    </div>
    
    <!-- å¼•æ“çŠ¶æ€ -->
    <div class="engine-status" id="engine-status">
        <span class="engine-icon">âš™ï¸</span>
        <span id="engine-text">åˆå§‹åŒ–ä¸­...</span>
    </div>
    
    <!-- æ‘„åƒå¤´é¢„è§ˆ -->
    <div class="camera-container" id="camera-container">
        <video id="camera-video" autoplay playsinline muted></video>
        <canvas id="camera-canvas"></canvas>
    </div>
    
    <!-- æ‰‹åŠ¿çŠ¶æ€ -->
    <div class="hand-status" id="hand-status">
        <span>ğŸ‘‹</span>
        <span id="hand-text">ç­‰å¾…æ‰‹åŠ¿è¯†åˆ«å¯åŠ¨...</span>
    </div>
    
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <div class="control-btn" id="btn-tree" title="åœ£è¯æ ‘å½¢æ€">ğŸ„</div>
        <div class="control-btn" id="btn-scatter" title="æ•£å¼€å½¢æ€">âœ¨</div>
        <div class="control-btn" id="btn-toggle-camera" title="å¼€å…³æ‘„åƒå¤´">ğŸ“·</div>
        <div class="control-btn" id="btn-reload-engine" title="é‡è½½è¯†åˆ«å¼•æ“">ğŸ”„</div>
    </div>

    <script>
        // ==================== é…ç½®å‚æ•° ====================
        const CONFIG = {
            // è§†è§‰é…ç½®
            colors: {
                bg: 0x000000, 
                champagneGold: 0xffd966, 
                deepGreen: 0x03180a,     
                accentRed: 0x990000,     
            },
            
            // æ€§èƒ½é…ç½®
            particles: {
                count: window.innerWidth < 768 ? 150 : 300,
                dustCount: window.innerWidth < 768 ? 300 : 600,
                treeHeight: 14,  
                treeRadius: 3    
            },
            
            // æ‰‹åŠ¿é…ç½®
            gesture: {
                // åŒå¼•æ“é…ç½®
                enginePriority: ['mediapipe', 'handtrackjs'],
                
                // é€šç”¨é˜ˆå€¼
                fistThreshold: 0.12,
                openHandThreshold: 0.3,
                pinchThreshold: 0.08,
                rotationSensitivity: 2.0,
                
                // ç¨³å®šæ€§è®¾ç½®
                gestureBufferSize: 5,
                gestureConfidence: 0.6,
                cooldownMs: 800
            }
        };
        
        // ==================== åº”ç”¨çŠ¶æ€ ====================
        const STATE = {
            // åœºæ™¯çŠ¶æ€
            mode: 'TREE', // TREE, SCATTER, FOCUS
            focusTarget: null,
            
            // æ‰‹åŠ¿çŠ¶æ€
            hand: {
                detected: false,
                position: { x: 0, y: 0 },
                gesture: 'NONE',
                gestureHistory: [],
                lastGestureTime: 0
            },
            
            // å¼•æ“çŠ¶æ€
            detectionEngine: null, // 'mediapipe', 'handtrackjs', null
            engineLoaded: false,
            
            // ç³»ç»ŸçŠ¶æ€
            cameraEnabled: false,
            autoRotate: true,
            rotation: { x: 0, y: 0 }
        };
        
        // ==================== å…¨å±€å˜é‡ ====================
        // Three.js å˜é‡
        let scene, camera, renderer, composer;
        let mainGroup, clock, particleSystem, photoMeshGroup;
        
        // æ‰‹åŠ¿è¯†åˆ«å˜é‡
        let videoElement, canvasElement, canvasCtx;
        let mediaPipeDetector = null;
        let handTrackModel = null;
        let videoStream = null;
        
        // ==================== æ ¸å¿ƒåˆå§‹åŒ– ====================
        async function init() {
            try {
                console.log('=== å¼€å§‹åˆå§‹åŒ–åº”ç”¨ ===');
                
                // 1. åˆå§‹åŒ–3Dåœºæ™¯
                initThreeJS();
                console.log('âœ… Three.js åˆå§‹åŒ–å®Œæˆ');
                
                // 2. è®¾ç½®3Dç¯å¢ƒ
                setupEnvironment();
                setupLights();
                createTextures();
                createParticles();
                createDust();
                createDefaultPhotos();
                setupPostProcessing();
                
                // 3. åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«ï¼ˆåŒå¼•æ“ï¼‰
                await initHandDetection();
                
                // 4. è®¾ç½®UIäº‹ä»¶
                setupUIEvents();
                
                // 5. å®Œæˆåˆå§‹åŒ–
                setTimeout(() => {
                    const loader = document.getElementById('loader');
                    if (loader) {
                        loader.style.opacity = '0';
                        setTimeout(() => loader.style.display = 'none', 1000);
                    }
                }, 1000);
                
                // 6. å¯åŠ¨åŠ¨ç”»å¾ªç¯
                animate();
                
                console.log('=== åº”ç”¨åˆå§‹åŒ–å®Œæˆ ===');
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                showStatusHint('åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢', true);
            }
        }
        
        // ==================== 3Dåœºæ™¯åˆå§‹åŒ– ====================
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, CONFIG.particles.treeHeight * 1.5);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: false, 
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.8;
            container.appendChild(renderer.domElement);
            
            // åˆ›å»ºä¸»å®¹å™¨
            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            
            // åˆå§‹åŒ–å…¶ä»–å˜é‡
            clock = new THREE.Clock();
            particleSystem = [];
            photoMeshGroup = new THREE.Group();
            mainGroup.add(photoMeshGroup);
        }
        
        function setupEnvironment() {
            // ç®€åŒ–çš„ç¯å¢ƒå…‰
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            
            const mainLight = new THREE.DirectionalLight(0xffeedd, 0.8);
            mainLight.position.set(10, 20, 15);
            scene.add(mainLight);
        }
        
        function setupLights() {
            const treeLight = new THREE.PointLight(0xffaa00, 1.5, 15);
            treeLight.position.set(0, 5, 0);
            mainGroup.add(treeLight);
            
            const rimLight = new THREE.DirectionalLight(0x6688ff, 0.4);
            rimLight.position.set(-10, 5, -10);
            scene.add(rimLight);
        }
        
        function setupPostProcessing() {
            // ç§»åŠ¨ç«¯ç¦ç”¨åæœŸå¤„ç†
            if (window.innerWidth < 768 || typeof THREE.EffectComposer === 'undefined') return;
            
            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight), 
                    0.7, 0.4, 0.8
                );
                
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
            } catch (error) {
                console.warn('åæœŸå¤„ç†åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }
        
        // ==================== æ‰‹åŠ¿è¯†åˆ«åŒå¼•æ“ ====================
        async function initHandDetection() {
            console.log('å¼€å§‹åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«å¼•æ“...');
            
            // è·å–DOMå…ƒç´ 
            videoElement = document.getElementById('camera-video');
            canvasElement = document.getElementById('camera-canvas');
            canvasCtx = canvasElement.getContext('2d');
            
            // è®¾ç½®Canvaså°ºå¯¸
            canvasElement.width = 140;
            canvasElement.height = 105;
            
            // 1. å…ˆåˆå§‹åŒ–æ‘„åƒå¤´
            try {
                await setupCamera();
                console.log('âœ… æ‘„åƒå¤´åˆå§‹åŒ–æˆåŠŸ');
                updateHandStatus('æ‘„åƒå¤´å°±ç»ªï¼Œå¯åŠ¨è¯†åˆ«å¼•æ“...');
            } catch (error) {
                console.error('âŒ æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error);
                updateHandStatus('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥');
                showStatusHint('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™', true);
                return;
            }
            
            // 2. æŒ‰ä¼˜å…ˆçº§å°è¯•ä¸åŒå¼•æ“
            for (const engine of CONFIG.gesture.enginePriority) {
                try {
                    console.log(`å°è¯•åŠ è½½ ${engine}...`);
                    updateEngineStatus(`æ­£åœ¨åŠ è½½ ${engine}...`);
                    
                    if (engine === 'mediapipe') {
                        await initMediaPipe();
                        STATE.detectionEngine = 'mediapipe';
                        console.log('âœ… MediaPipe åŠ è½½æˆåŠŸ');
                        updateEngineStatus('MediaPipe');
                        updateHandStatus('é«˜çº§æ‰‹åŠ¿è¯†åˆ«å·²å¯åŠ¨');
                        showStatusHint('é«˜çº§æ‰‹åŠ¿è¯†åˆ«å·²å¯ç”¨', false);
                        break; // æˆåŠŸåˆ™é€€å‡ºå¾ªç¯
                    } 
                    else if (engine === 'handtrackjs') {
                        await initHandTrackJS();
                        STATE.detectionEngine = 'handtrackjs';
                        console.log('âœ… Handtrack.js åŠ è½½æˆåŠŸ');
                        updateEngineStatus('Handtrack.js');
                        updateHandStatus('åŸºç¡€æ‰‹åŠ¿è¯†åˆ«å·²å¯åŠ¨');
                        showStatusHint('åŸºç¡€æ‰‹åŠ¿è¯†åˆ«å·²å¯ç”¨', false);
                        break; // æˆåŠŸåˆ™é€€å‡ºå¾ªç¯
                    }
                } catch (engineError) {
                    console.warn(`${engine} åŠ è½½å¤±è´¥:`, engineError);
                    continue; // å°è¯•ä¸‹ä¸€ä¸ªå¼•æ“
                }
            }
            
            // 3. æ£€æŸ¥æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªå¼•æ“åŠ è½½æˆåŠŸ
            if (!STATE.detectionEngine) {
                console.error('âŒ æ‰€æœ‰æ‰‹åŠ¿è¯†åˆ«å¼•æ“å‡å¤±è´¥');
                updateEngineStatus('æ— å¯ç”¨å¼•æ“');
                updateHandStatus('æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥');
                showStatusHint('æ‰‹åŠ¿è¯†åˆ«ä¸å¯ç”¨ï¼Œä½¿ç”¨æŒ‰é’®æ§åˆ¶', true);
            } else {
                STATE.engineLoaded = true;
                console.log(`âœ… æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å®Œæˆï¼Œä½¿ç”¨å¼•æ“: ${STATE.detectionEngine}`);
            }
        }
        
        // æ‘„åƒå¤´åˆå§‹åŒ–
        async function setupCamera() {
            return new Promise((resolve, reject) => {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    reject(new Error('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®'));
                    return;
                }
                
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 24 }
                    }
                };
                
                navigator.mediaDevices.getUserMedia(constraints)
                    .then(stream => {
                        videoStream = stream;
                        videoElement.srcObject = stream;
                        STATE.cameraEnabled = true;
                        
                        document.getElementById('camera-container').classList.add('active');
                        
                        videoElement.onloadedmetadata = () => {
                            videoElement.play();
                            resolve();
                        };
                        
                        videoElement.onerror = () => {
                            reject(new Error('è§†é¢‘æ’­æ”¾å¤±è´¥'));
                        };
                    })
                    .catch(error => {
                        console.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥:', error);
                        reject(error);
                    });
            });
        }
        
        // MediaPipe å¼•æ“åˆå§‹åŒ–
        async function initMediaPipe() {
            return new Promise(async (resolve, reject) => {
                try {
                    // æ£€æŸ¥æ˜¯å¦å·²åŠ è½½
                    if (typeof window.FilesetResolver === 'undefined') {
                        reject(new Error('MediaPipeåº“æœªåŠ è½½'));
                        return;
                    }
                    
                    // åˆå§‹åŒ–MediaPipe
                    const vision = await window.FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                    );
                    
                    mediaPipeDetector = await window.HandLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                            delegate: "GPU"
                        },
                        runningMode: "VIDEO",
                        numHands: 1
                    });
                    
                    // å¯åŠ¨æ£€æµ‹å¾ªç¯
                    startMediaPipeDetection();
                    resolve();
                } catch (error) {
                    console.error('MediaPipeåˆå§‹åŒ–å¤±è´¥:', error);
                    reject(error);
                }
            });
        }
        
        // Handtrack.js å¼•æ“åˆå§‹åŒ–
        async function initHandTrackJS() {
            return new Promise(async (resolve, reject) => {
                try {
                    // æ£€æŸ¥æ˜¯å¦å·²åŠ è½½
                    if (typeof handTrack === 'undefined') {
                        reject(new Error('Handtrack.jsåº“æœªåŠ è½½'));
                        return;
                    }
                    
                    // åŠ è½½æ¨¡å‹
                    const modelParams = {
                        flipHorizontal: true,
                        maxNumBoxes: 1,
                        scoreThreshold: 0.7,
                        iouThreshold: 0.5,
                        modelType: "ssd320fpnlite",
                    };
                    
                    handTrackModel = await handTrack.load(modelParams);
                    
                    // å¯åŠ¨æ£€æµ‹å¾ªç¯
                    startHandTrackDetection();
                    resolve();
                } catch (error) {
                    console.error('Handtrack.jsåˆå§‹åŒ–å¤±è´¥:', error);
                    reject(error);
                }
            });
        }
        
        // MediaPipe æ£€æµ‹å¾ªç¯
        function startMediaPipeDetection() {
            let lastVideoTime = -1;
            
            function detectFrame() {
                if (!STATE.cameraEnabled || !mediaPipeDetector || STATE.detectionEngine !== 'mediapipe') {
                    return;
                }
                
                const currentTime = videoElement.currentTime;
                if (currentTime !== lastVideoTime) {
                    lastVideoTime = currentTime;
                    
                    try {
                        const results = mediaPipeDetector.detectForVideo(videoElement, performance.now());
                        processMediaPipeResults(results);
                        drawMediaPipeResults(results);
                    } catch (error) {
                        console.error('MediaPipeæ£€æµ‹é”™è¯¯:', error);
                    }
                }
                
                requestAnimationFrame(detectFrame);
            }
            
            detectFrame();
        }
        
        // Handtrack.js æ£€æµ‹å¾ªç¯
        function startHandTrackDetection() {
            function detectFrame() {
                if (!STATE.cameraEnabled || !handTrackModel || STATE.detectionEngine !== 'handtrackjs') {
                    return;
                }
                
                handTrackModel.detect(videoElement).then(predictions => {
                    processHandTrackResults(predictions);
                    drawHandTrackResults(predictions);
                    
                    if (STATE.detectionEngine === 'handtrackjs') {
                        requestAnimationFrame(detectFrame);
                    }
                }).catch(error => {
                    console.error('Handtrack.jsæ£€æµ‹é”™è¯¯:', error);
                    setTimeout(detectFrame, 1000);
                });
            }
            
            detectFrame();
        }
        
        // ==================== æ‰‹åŠ¿å¤„ç†é€»è¾‘ ====================
        // å¤„ç†MediaPipeç»“æœ
        function processMediaPipeResults(results) {
            if (!results.landmarks || results.landmarks.length === 0) {
                STATE.hand.detected = false;
                updateHandStatus('æœªæ£€æµ‹åˆ°æ‰‹éƒ¨');
                return;
            }
            
            STATE.hand.detected = true;
            const landmarks = results.landmarks[0];
            
            // æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
            const gesture = recognizeMediaPipeGesture(landmarks);
            updateGestureState(gesture);
            
            // æ‰‹éƒ¨ä½ç½®è·Ÿè¸ªï¼ˆç”¨äºæ—‹è½¬æ§åˆ¶ï¼‰
            const wrist = landmarks[0];
            STATE.hand.position.x = wrist.x;
            STATE.hand.position.y = wrist.y;
        }
        
        // å¤„ç†Handtrack.jsç»“æœ
        function processHandTrackResults(predictions) {
            if (!predictions || predictions.length === 0) {
                STATE.hand.detected = false;
                updateHandStatus('æœªæ£€æµ‹åˆ°æ‰‹éƒ¨');
                return;
            }
            
            STATE.hand.detected = true;
            const bbox = predictions[0].bbox;
            
            // è®¡ç®—æ‰‹éƒ¨ä¸­å¿ƒä½ç½®
            const centerX = bbox[0] + bbox[2] / 2;
            const centerY = bbox[1] + bbox[3] / 2;
            
            STATE.hand.position.x = centerX / canvasElement.width;
            STATE.hand.position.y = centerY / canvasElement.height;
            
            // ç®€åŒ–çš„æ‰‹åŠ¿è¯†åˆ«ï¼ˆåŸºäºæ£€æµ‹æ¡†å¤§å°ï¼‰
            const handArea = bbox[2] * bbox[3];
            let gesture = 'NONE';
            
            if (handArea > 8000) gesture = 'OPEN';
            else if (handArea < 4000) gesture = 'FIST';
            
            updateGestureState(gesture);
        }
        
        // è¯†åˆ«MediaPipeæ‰‹åŠ¿
        function recognizeMediaPipeGesture(landmarks) {
            // ç®€åŒ–çš„æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
            // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥æœ‰æ›´å¤æ‚çš„æ‰‹åŠ¿è¯†åˆ«ç®—æ³•
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const wrist = landmarks[0];
            
            // è®¡ç®—è·ç¦»
            const pinchDist = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );
            
            // æ‰‹åŠ¿åˆ¤æ–­
            if (pinchDist < 0.05) return 'PINCH';
            
            // å…¶ä»–æ‰‹åŠ¿åˆ¤æ–­...
            return 'NONE';
        }
        
        // æ›´æ–°æ‰‹åŠ¿çŠ¶æ€
        function updateGestureState(gesture) {
            // æ‰‹åŠ¿å†·å´
            const now = Date.now();
            if (now - STATE.hand.lastGestureTime < CONFIG.gesture.cooldownMs) {
                return;
            }
            
            // æ·»åŠ åˆ°å†å²è®°å½•
            STATE.hand.gestureHistory.push(gesture);
            if (STATE.hand.gestureHistory.length > CONFIG.gesture.gestureBufferSize) {
                STATE.hand.gestureHistory.shift();
            }
            
            // ä»å†å²è®°å½•ä¸­ç¡®å®šæœ€é¢‘ç¹çš„æ‰‹åŠ¿
            const gestureCount = {};
            STATE.hand.gestureHistory.forEach(g => {
                gestureCount[g] = (gestureCount[g] || 0) + 1;
            });
            
            let finalGesture = 'NONE';
            let maxCount = 0;
            for (const [g, count] of Object.entries(gestureCount)) {
                if (count > maxCount) {
                    maxCount = count;
                    finalGesture = g;
                }
            }
            
            // åº”ç”¨æ‰‹åŠ¿
            if (finalGesture !== 'NONE' && finalGesture !== STATE.hand.gesture) {
                STATE.hand.gesture = finalGesture;
                STATE.hand.lastGestureTime = now;
                
                applyGesture(finalGesture);
                updateHandStatus(getGestureText(finalGesture));
            }
        }
        
        // åº”ç”¨æ‰‹åŠ¿åˆ°åœºæ™¯
        function applyGesture(gesture) {
            switch (gesture) {
                case 'FIST':
                    if (STATE.mode !== 'TREE') {
                        STATE.mode = 'TREE';
                        STATE.autoRotate = true;
                        showStatusHint('åˆ‡æ¢åˆ°åœ£è¯æ ‘å½¢æ€', false);
                    }
                    break;
                    
                case 'OPEN':
                    if (STATE.mode !== 'SCATTER') {
                        STATE.mode = 'SCATTER';
                        STATE.autoRotate = false;
                        showStatusHint('åˆ‡æ¢åˆ°æ•£å¼€å½¢æ€', false);
                    }
                    break;
                    
                case 'PINCH':
                    if (STATE.mode === 'SCATTER') {
                        const photos = particleSystem.filter(p => p.type === 'PHOTO');
                        if (photos.length > 0) {
                            STATE.mode = 'FOCUS';
                            STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh;
                            showStatusHint('æ”¾å¤§ç…§ç‰‡', false);
                        }
                    }
                    break;
            }
            
            updateSceneMode();
        }
        
        // ==================== ç»˜å›¾å‡½æ•° ====================
        function drawMediaPipeResults(results) {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (!results.landmarks || results.landmarks.length === 0) return;
            
            // ç»˜åˆ¶æ‰‹åŠ¿è¯†åˆ«ç»“æœ
            const landmarks = results.landmarks[0];
            const connections = window.HAND_CONNECTIONS || [];
            
            // ç»˜åˆ¶è¿æ¥çº¿
            canvasCtx.strokeStyle = '#00ff00';
            canvasCtx.lineWidth = 2;
            
            connections.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                canvasCtx.beginPath();
                canvasCtx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
                canvasCtx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
                canvasCtx.stroke();
            });
        }
        
        function drawHandTrackResults(predictions) {
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (!predictions || predictions.length === 0) return;
            
            // ç»˜åˆ¶æ£€æµ‹æ¡†
            const bbox = predictions[0].bbox;
            canvasCtx.strokeStyle = '#ff4444';
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeRect(bbox[0], bbox[1], bbox[2], bbox[3]);
            
            // ç»˜åˆ¶æ‰‹åŠ¿æ ‡ç­¾
            canvasCtx.fillStyle = '#ff4444';
            canvasCtx.font = '12px Arial';
            canvasCtx.fillText(STATE.hand.gesture, bbox[0], bbox[1] - 5);
        }
        
        // ==================== UIæ›´æ–°å‡½æ•° ====================
        function updateEngineStatus(text) {
            const engineText = document.getElementById('engine-text');
            const engineStatus = document.getElementById('engine-status');
            
            if (engineText) engineText.textContent = text;
            
            // æ ¹æ®å¼•æ“çŠ¶æ€æ”¹å˜é¢œè‰²
            if (engineStatus) {
                if (text.includes('MediaPipe')) {
                    engineStatus.style.borderColor = 'rgba(66, 133, 244, 0.6)';
                } else if (text.includes('Handtrack')) {
                    engineStatus.style.borderColor = 'rgba(255, 107, 107, 0.6)';
                } else {
                    engineStatus.style.borderColor = 'rgba(212, 175, 55, 0.3)';
                }
            }
        }
        
        function updateHandStatus(text) {
            const handText = document.getElementById('hand-text');
            if (handText) handText.textContent = text;
        }
        
        function getGestureText(gesture) {
            const texts = {
                'FIST': 'âœŠ æ¡æ‹³',
                'OPEN': 'ğŸ–ï¸ å¼ å¼€æ‰‹',
                'PINCH': 'ğŸ¤ æåˆ',
                'NONE': 'ğŸ‘‹ ç­‰å¾…æ‰‹åŠ¿'
            };
            return texts[gesture] || gesture;
        }
        
        function showStatusHint(text, isError = false) {
            const hint = document.getElementById('status-hint');
            if (!hint) return;
            
            hint.textContent = text;
            hint.style.color = isError ? '#ff6b6b' : '#d4af37';
            hint.style.borderColor = isError ? 'rgba(255, 107, 107, 0.3)' : 'rgba(212, 175, 55, 0.3)';
            hint.classList.add('show');
            
            setTimeout(() => {
                hint.classList.remove('show');
            }, 2000);
        }
        
        // ==================== UIäº‹ä»¶å¤„ç† ====================
        function setupUIEvents() {
            // æ§åˆ¶æŒ‰é’®
            document.getElementById('btn-tree').addEventListener('click', () => {
                STATE.mode = 'TREE';
                STATE.autoRotate = true;
                updateSceneMode();
                showStatusHint('åˆ‡æ¢åˆ°åœ£è¯æ ‘å½¢æ€', false);
            });
            
            document.getElementById('btn-scatter').addEventListener('click', () => {
                STATE.mode = 'SCATTER';
                STATE.autoRotate = false;
                updateSceneMode();
                showStatusHint('åˆ‡æ¢åˆ°æ•£å¼€å½¢æ€', false);
            });
            
            document.getElementById('btn-toggle-camera').addEventListener('click', toggleCamera);
            document.getElementById('btn-reload-engine').addEventListener('click', reloadHandDetection);
            
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
        }
        
        function toggleCamera() {
            if (!STATE.cameraEnabled) {
                initHandDetection();
            } else {
                if (videoStream) {
                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = null;
                }
                videoElement.srcObject = null;
                STATE.cameraEnabled = false;
                document.getElementById('camera-container').classList.remove('active');
                updateHandStatus('æ‘„åƒå¤´å·²å…³é—­');
            }
        }
        
        async function reloadHandDetection() {
            showStatusHint('é‡æ–°åŠ è½½æ‰‹åŠ¿è¯†åˆ«å¼•æ“...', false);
            
            // æ¸…ç†ç°æœ‰å¼•æ“
            if (mediaPipeDetector) {
                mediaPipeDetector.close();
                mediaPipeDetector = null;
            }
            
            if (handTrackModel) {
                handTrackModel.dispose();
                handTrackModel = null;
            }
            
            // é‡æ–°åˆå§‹åŒ–
            STATE.detectionEngine = null;
            STATE.engineLoaded = false;
            
            await initHandDetection();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // ==================== 3Dç²’å­ç³»ç»Ÿ ====================
        class Particle {
            constructor(mesh, type) {
                this.mesh = mesh;
                this.type = type;
                this.isPhoto = type === 'PHOTO';
                
                // è®¡ç®—åˆå§‹ä½ç½®
                this.calculatePositions();
                
                // éšæœºæ—‹è½¬é€Ÿåº¦
                this.spinSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
            }
            
            calculatePositions() {
                const h = CONFIG.particles.treeHeight;
                const halfH = h / 2;
                let t = Math.random();
                t = Math.pow(t, 0.8);
                const y = (t * h) - halfH;
                let rMax = CONFIG.particles.treeRadius * (1.0 - t);
                if (rMax < 0.2) rMax = 0.2;
                const angle = t * 25 * Math.PI + Math.random() * Math.PI;
                const r = rMax * (0.8 + Math.random() * 0.4);
                
                // åœ£è¯æ ‘ä½ç½®
                this.treePos = new THREE.Vector3(
                    Math.cos(angle) * r,
                    y,
                    Math.sin(angle) * r
                );
                
                // æ•£å¼€ä½ç½®
                const scatterR = 8 + Math.random() * 4;
                const scatterTheta = Math.random() * Math.PI * 2;
                const scatterPhi = Math.acos(2 * Math.random() - 1);
                
                this.scatterPos = new THREE.Vector3(
                    scatterR * Math.sin(scatterPhi) * Math.cos(scatterTheta),
                    scatterR * Math.sin(scatterPhi) * Math.sin(scatterTheta),
                    scatterR * Math.cos(scatterPhi)
                );
                
                // ç„¦ç‚¹ä½ç½®
                this.focusPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 8,
                    5 + Math.random() * 5
                );
            }
            
            update(dt) {
                let targetPos, targetScale, lookAtCamera = false;
                
                switch (STATE.mode) {
                    case 'TREE':
                        targetPos = this.treePos;
                        targetScale = this.isPhoto ? 0.4 : 0.15;
                        break;
                        
                    case 'SCATTER':
                        targetPos = this.scatterPos;
                        targetScale = this.isPhoto ? 0.6 : 0.2;
                        
                        // æ·»åŠ æ—‹è½¬
                        this.mesh.rotation.x += this.spinSpeed.x * dt;
                        this.mesh.rotation.y += this.spinSpeed.y * dt;
                        this.mesh.rotation.z += this.spinSpeed.z * dt;
                        break;
                        
                    case 'FOCUS':
                        if (this.mesh === STATE.focusTarget) {
                            targetPos = new THREE.Vector3(0, 0, 10);
                            targetScale = 2.5;
                            lookAtCamera = true;
                        } else {
                            targetPos = this.focusPos;
                            targetScale = this.isPhoto ? 0.3 : 0.1;
                        }
                        break;
                }
                
                // å¹³æ»‘è¿‡æ¸¡
                const lerpSpeed = (STATE.mode === 'FOCUS' && this.mesh === STATE.focusTarget) ? 5.0 : 2.0;
                this.mesh.position.lerp(targetPos, lerpSpeed * dt);
                
                const targetScaleVec = new THREE.Vector3(targetScale, targetScale, targetScale);
                this.mesh.scale.lerp(targetScaleVec, lerpSpeed * dt);
                
                if (lookAtCamera) {
                    this.mesh.lookAt(camera.position);
                }
            }
        }
        
        function createTextures() {
            // åˆ›å»ºç®€å•çš„çº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // åˆ›å»ºæ¡çº¹çº¹ç†
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = '#880000';
            ctx.beginPath();
            for (let i = -64; i < 128; i += 16) {
                ctx.moveTo(i, 0);
                ctx.lineTo(i + 16, 64);
                ctx.lineTo(i + 8, 64);
                ctx.lineTo(i - 8, 0);
            }
            ctx.fill();
            
            // åˆ›å»ºçº¹ç†
            caneTexture = new THREE.CanvasTexture(canvas);
            caneTexture.wrapS = caneTexture.wrapT = THREE.RepeatWrapping;
            caneTexture.repeat.set(2, 2);
        }
        
        function createParticles() {
            // æè´¨
            const goldMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.champagneGold,
                metalness: 0.7,
                roughness: 0.3
            });
            
            const greenMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.deepGreen,
                roughness: 0.8
            });
            
            const redMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.accentRed,
                metalness: 0.3,
                roughness: 0.4
            });
            
            const candyMat = new THREE.MeshStandardMaterial({
                map: caneTexture,
                roughness: 0.6
            });
            
            // å‡ ä½•ä½“
            const sphereGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const boxGeo = new THREE.BoxGeometry(0.18, 0.18, 0.18);
            
            // åˆ›å»ºè£…é¥°ç²’å­
            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random();
                let mesh, type = 'DECORATION';
                
                if (rand < 0.4) {
                    mesh = new THREE.Mesh(boxGeo, greenMat);
                } else if (rand < 0.7) {
                    mesh = new THREE.Mesh(boxGeo, goldMat);
                } else if (rand < 0.9) {
                    mesh = new THREE.Mesh(sphereGeo, goldMat);
                } else {
                    mesh = new THREE.Mesh(sphereGeo, redMat);
                }
                
                mesh.castShadow = true;
                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, type));
            }
            
            // åˆ›å»ºæ ‘é¡¶æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(0.4, 0);
            const starMat = new THREE.MeshStandardMaterial({
                color: 0xffdd88,
                emissive: 0xffaa00,
                emissiveIntensity: 0.8
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.particles.treeHeight / 2 + 0.3, 0);
            mainGroup.add(star);
        }
        
        function createDust() {
            const dustGeo = new THREE.TetrahedronGeometry(0.05, 0);
            const dustMat = new THREE.MeshBasicMaterial({
                color: 0xffeebb,
                transparent: true,
                opacity: 0.4
            });
            
            for (let i = 0; i < CONFIG.particles.dustCount; i++) {
                const dust = new THREE.Mesh(dustGeo, dustMat);
                dust.scale.setScalar(0.5 + Math.random() * 0.5);
                dust.position.set(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );
                mainGroup.add(dust);
                particleSystem.push(new Particle(dust, 'DUST'));
            }
        }
        
        function createDefaultPhotos() {
            const photos = [
                { text: "åœ£è¯\nå¿«ä¹", color: "#d4af37" },
                { text: "æ–°å¹´\nå¿«ä¹", color: "#4ecdc4" },
                { text: "å¹³å®‰\nå–œä¹", color: "#ff6b6b" }
            ];
            
            photos.forEach(photo => {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // èƒŒæ™¯
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, 256, 256);
                
                // è¾¹æ¡†
                ctx.strokeStyle = photo.color;
                ctx.lineWidth = 8;
                ctx.strokeRect(12, 12, 232, 232);
                
                // æ–‡å­—
                ctx.fillStyle = photo.color;
                ctx.font = 'bold 36px "Microsoft YaHei", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const lines = photo.text.split('\n');
                lines.forEach((line, i) => {
                    ctx.fillText(line, 128, 128 - 25 + (i * 50));
                });
                
                // åˆ›å»ºç…§ç‰‡ç½‘æ ¼
                const texture = new THREE.CanvasTexture(canvas);
                texture.colorSpace = THREE.SRGBColorSpace;
                
                const frameGeo = new THREE.BoxGeometry(1.0, 1.4, 0.03);
                const frameMat = new THREE.MeshStandardMaterial({
                    color: 0xd4af37,
                    metalness: 0.6,
                    roughness: 0.4
                });
                
                const photoGeo = new THREE.PlaneGeometry(0.9, 1.3);
                const photoMat = new THREE.MeshBasicMaterial({ map: texture });
                
                const frame = new THREE.Mesh(frameGeo, frameMat);
                const photo = new THREE.Mesh(photoGeo, photoMat);
                photo.position.z = 0.02;
                
                const photoGroup = new THREE.Group();
                photoGroup.add(frame);
                photoGroup.add(photo);
                photoGroup.scale.setScalar(0.5);
                
                photoMeshGroup.add(photoGroup);
                particleSystem.push(new Particle(photoGroup, 'PHOTO'));
            });
        }
        
        function updateSceneMode() {
            // æ›´æ–°UIæŒ‡ç¤ºå™¨
            const modeText = document.getElementById('mode-text');
            const modeIcon = document.querySelector('.status-icon');
            
            if (modeText && modeIcon) {
                switch (STATE.mode) {
                    case 'TREE':
                        modeText.textContent = 'åœ£è¯æ ‘å½¢æ€';
                        modeIcon.textContent = 'ğŸ„';
                        break;
                    case 'SCATTER':
                        modeText.textContent = 'æ•£å¼€å½¢æ€';
                        modeIcon.textContent = 'âœ¨';
                        break;
                    case 'FOCUS':
                        modeText.textContent = 'èšç„¦ç…§ç‰‡';
                        modeIcon.textContent = 'ğŸ“¸';
                        break;
                }
            }
        }
        
        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.033);
            
            // è‡ªåŠ¨æ—‹è½¬
            if (STATE.autoRotate && STATE.mode === 'TREE') {
                mainGroup.rotation.y += 0.1 * dt;
            }
            
            // æ›´æ–°ç²’å­
            particleSystem.forEach(particle => {
                particle.update(dt);
            });
            
            // æ¸²æŸ“åœºæ™¯
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }
        
        // ==================== å¯åŠ¨åº”ç”¨ ====================
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            setTimeout(init, 100);
        });
        
        // åŠ è½½è¶…æ—¶å¤„ç†
        setTimeout(() => {
            const loader = document.getElementById('loader');
            if (loader && loader.style.display !== 'none') {
                showStatusHint('åŠ è½½æ—¶é—´è¾ƒé•¿ï¼Œè¯·è€å¿ƒç­‰å¾…...', false);
            }
        }, 5000);
    </script>
</body>
</html>
