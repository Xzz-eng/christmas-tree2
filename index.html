<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>3Dåœ£è¯æ ‘ - ç¨³å®šæ‰‹åŠ¿æ§åˆ¶ç‰ˆ</title>
    
    <!-- Three.js æ ¸å¿ƒåº“ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <!-- ä¸å†åŠ è½½å¤æ‚çš„é™„åŠ ç»„ä»¶ï¼Œä»¥æé«˜åŠ è½½é€Ÿåº¦ -->
    
    <!-- æ‰‹åŠ¿è¯†åˆ«ï¼šä½¿ç”¨æ›´ç¨³å®šçš„CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.2/vision_bundle.js"></script>
    <script src="https://unpkg.com/handtrackjs@0.0.13/dist/handtrack.min.js"></script>

    <style>
        :root {
            --safe-area-inset-top: env(safe-area-inset-top, 0px);
            --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            box-sizing: border-box;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
            position: fixed;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
        }
        
        /* åŠ è½½ç•Œé¢ */
        #loader {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100vw; 
            height: 100vh;
            background: #000; 
            z-index: 100;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            transition: opacity 1s ease-out;
        }
        
        .loader-text {
            color: #d4af37; 
            font-size: 14px; 
            letter-spacing: 2px; 
            margin-top: 20px;
            text-transform: uppercase; 
            font-weight: 300;
            text-align: center;
            padding: 0 20px;
        }
        
        .spinner {
            width: 30px; 
            height: 30px; 
            border: 1px solid rgba(212, 175, 55, 0.2); 
            border-top: 1px solid #d4af37; 
            border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        
        /* å¼•æ“çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .engine-status {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: #d4af37;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 11px;
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
        
        /* æ‘„åƒå¤´ç•Œé¢ */
        .camera-container {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 140px;
            height: 105px;
            border-radius: 8px;
            overflow: hidden;
            z-index: 15;
            border: 2px solid rgba(212, 175, 55, 0.3);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
            background: #000;
        }
        
        #camera-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #camera-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* è°ƒè¯•ä¿¡æ¯é¢æ¿ */
        .debug-panel {
            position: fixed;
            bottom: 130px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: #4ecdc4;
            padding: 10px;
            border-radius: 8px;
            font-size: 10px;
            font-family: monospace;
            max-width: 200px;
            max-height: 150px;
            overflow-y: auto;
            z-index: 25;
            border: 1px solid rgba(78, 205, 196, 0.3);
            display: none; /* é»˜è®¤éšè—ï¼Œè°ƒè¯•æ—¶å¼€å¯ */
        }
        
        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            position: fixed;
            bottom: 15px;
            left: 15px;
            display: flex;
            gap: 10px;
            z-index: 20;
        }
        
        .control-btn {
            background: rgba(30, 30, 30, 0.7);
            border: 1px solid rgba(212, 175, 55, 0.4);
            color: #d4af37;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            touch-action: manipulation;
            backdrop-filter: blur(10px);
        }
        
        .control-btn:active {
            background: rgba(212, 175, 55, 0.3);
            transform: scale(0.95);
        }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-container {
            position: fixed;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
        }
        
        .status-item {
            background: rgba(0, 0, 0, 0.7);
            color: #d4af37;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.3);
            max-width: 200px;
        }
        
        /* ä¿®å¤æŒ‰é’® */
        .fix-btn {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(212, 175, 55, 0.9);
            color: #000;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            display: none;
            border: none;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
        }
    </style>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text" id="loader-text">åˆå§‹åŒ–ä¸­...</div>
    </div>
    
    <!-- ä¿®å¤æŒ‰é’® -->
    <button class="fix-btn" id="fix-btn" onclick="forceRetryHandDetection()">é‡è¯•æ‰‹åŠ¿è¯†åˆ«</button>
    
    <!-- è°ƒè¯•é¢æ¿ -->
    <div class="debug-panel" id="debug-panel"></div>

    <div id="canvas-container"></div>
    
    <!-- çŠ¶æ€å®¹å™¨ -->
    <div class="status-container">
        <div class="status-item" id="engine-status">
            <span>âš™ï¸</span>
            <span>å¼•æ“: åˆå§‹åŒ–ä¸­...</span>
        </div>
        <div class="status-item" id="hand-status">
            <span>ğŸ‘‹</span>
            <span>æ‰‹åŠ¿: ç­‰å¾…å¯åŠ¨...</span>
        </div>
        <div class="status-item" id="camera-status">
            <span>ğŸ“·</span>
            <span>æ‘„åƒå¤´: å…³é—­</span>
        </div>
    </div>
    
    <!-- æ‘„åƒå¤´é¢„è§ˆ -->
    <div class="camera-container" id="camera-container">
        <video id="camera-video" autoplay playsinline muted></video>
        <canvas id="camera-canvas"></canvas>
    </div>
    
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <div class="control-btn" id="btn-tree" title="åœ£è¯æ ‘å½¢æ€">ğŸ„</div>
        <div class="control-btn" id="btn-scatter" title="æ•£å¼€å½¢æ€">âœ¨</div>
        <div class="control-btn" id="btn-toggle-debug" title="æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯">ğŸ›</div>
        <div class="control-btn" id="btn-simple-mode" title="ç®€æ˜“æ‰‹åŠ¿æ¨¡å¼">ğŸ‘</div>
    </div>

    <script>
        // ==================== é…ç½®å‚æ•° ====================
        const CONFIG = {
            // ç®€åŒ–3Dåœºæ™¯ä»¥æé«˜æ€§èƒ½
            particles: {
                count: 80,      // å¤§å¹…å‡å°‘ç²’å­æ•°é‡
                treeHeight: 12,
                treeRadius: 3
            },
            
            // æ‰‹åŠ¿å¼•æ“é…ç½®
            gesture: {
                // è¶…æ—¶è®¾ç½®
                mediaPipeTimeout: 10000,  // MediaPipeåŠ è½½è¶…æ—¶(10ç§’)
                handTrackTimeout: 8000,   // HandtrackåŠ è½½è¶…æ—¶(8ç§’)
                cameraTimeout: 5000,      // æ‘„åƒå¤´è¶…æ—¶(5ç§’)
                
                // é‡è¯•é…ç½®
                maxRetries: 2,
                retryDelay: 2000
            }
        };

        // ==================== åº”ç”¨çŠ¶æ€ ====================
        const STATE = {
            // åœºæ™¯çŠ¶æ€
            mode: 'TREE', // TREE, SCATTER, FOCUS
            
            // æ‰‹åŠ¿çŠ¶æ€
            handDetected: false,
            simpleMode: false,  // ç®€æ˜“æ‰‹åŠ¿æ¨¡å¼
            
            // å¼•æ“çŠ¶æ€
            currentEngine: null, // 'mediapipe', 'handtrack', 'simple', 'none'
            retryCount: 0,
            
            // ç³»ç»ŸçŠ¶æ€
            cameraReady: false,
            initializationComplete: false
        };

        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer;
        let mainGroup, clock;
        let videoElement, canvasElement, canvasCtx;
        let videoStream = null;
        
        // ==================== è°ƒè¯•å·¥å…· ====================
        const DEBUG = {
            enabled: false,
            logs: [],
            
            log: function(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                this.logs.push(logEntry);
                
                console.log(`%c${logEntry}`, 
                    type === 'error' ? 'color: #ff6b6b' : 
                    type === 'success' ? 'color: #4ecdc4' : 
                    'color: #d4af37');
                
                if (this.enabled) {
                    this.updatePanel();
                }
            },
            
            updatePanel: function() {
                const panel = document.getElementById('debug-panel');
                if (panel) {
                    // åªæ˜¾ç¤ºæœ€è¿‘10æ¡æ—¥å¿—
                    const recentLogs = this.logs.slice(-10);
                    panel.innerHTML = recentLogs.map(log => 
                        `<div>${log}</div>`
                    ).join('');
                }
            },
            
            showPanel: function() {
                const panel = document.getElementById('debug-panel');
                if (panel) {
                    panel.style.display = 'block';
                    this.updatePanel();
                }
            },
            
            hidePanel: function() {
                const panel = document.getElementById('debug-panel');
                if (panel) {
                    panel.style.display = 'none';
                }
            }
        };

        // ==================== æ ¸å¿ƒåˆå§‹åŒ– ====================
        async function init() {
            try {
                DEBUG.log('å¼€å§‹åˆå§‹åŒ–åº”ç”¨');
                
                // 1. åˆå§‹åŒ–3Dåœºæ™¯ï¼ˆæœ€ç®€åŒ–ï¼‰
                initThreeJS();
                DEBUG.log('Three.jsåˆå§‹åŒ–å®Œæˆ', 'success');
                
                // 2. è®¾ç½®3Dç¯å¢ƒ
                setupScene();
                createChristmasTree();
                
                // 3. å¹¶è¡Œåˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«å’Œæ‘„åƒå¤´
                await Promise.all([
                    initHandDetection().catch(err => {
                        DEBUG.log(`æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥: ${err.message}`, 'error');
                    }),
                    setupCamera().catch(err => {
                        DEBUG.log(`æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥: ${err.message}`, 'error');
                    })
                ]);
                
                // 4. è®¾ç½®UIäº‹ä»¶
                setupUIEvents();
                
                // 5. éšè—åŠ è½½ç•Œé¢
                setTimeout(() => {
                    const loader = document.getElementById('loader');
                    if (loader) {
                        loader.style.opacity = '0';
                        setTimeout(() => loader.style.display = 'none', 1000);
                    }
                }, 1000);
                
                // 6. å¯åŠ¨åŠ¨ç”»å¾ªç¯
                animate();
                
                DEBUG.log('åº”ç”¨åˆå§‹åŒ–å®Œæˆ', 'success');
                STATE.initializationComplete = true;
                
            } catch (error) {
                DEBUG.log(`åˆå§‹åŒ–è¿‡ç¨‹å‡ºé”™: ${error.message}`, 'error');
                showFixButton('åˆå§‹åŒ–å¤±è´¥ï¼Œç‚¹å‡»é‡è¯•');
            }
        }

        // ==================== 3Dåœºæ™¯åˆå§‹åŒ– ====================
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 20);
            
            // åˆ›å»ºæ¸²æŸ“å™¨ï¼ˆæœ€ç®€åŒ–é…ç½®ï¼‰
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            // åˆ›å»ºä¸»å®¹å™¨
            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            
            // åˆå§‹åŒ–æ—¶é’Ÿ
            clock = new THREE.Clock();
        }

        function setupScene() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // ä¸»å…‰æº
            const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.8);
            directionalLight.position.set(10, 20, 15);
            scene.add(directionalLight);
            
            // ç‚¹å…‰æºï¼ˆæ ‘å†…ï¼‰
            const pointLight = new THREE.PointLight(0xffaa00, 1, 20);
            pointLight.position.set(0, 5, 0);
            mainGroup.add(pointLight);
        }

        function createChristmasTree() {
            // æ ‘å¹²çš„æè´¨
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9
            });
            
            // åˆ›å»ºæ ‘å¹²
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 2, 8);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(0, -1, 0);
            mainGroup.add(trunk);
            
            // æ ‘å¶çš„æè´¨
            const leafMaterial = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.8
            });
            
            // åˆ›å»ºå¤šå±‚æ ‘å¶ï¼ˆåœ†é”¥ä½“ï¼‰
            const layers = 4;
            for (let i = 0; i < layers; i++) {
                const radius = 2 - i * 0.4;
                const height = 2;
                const yPos = i * 1.5;
                
                const coneGeometry = new THREE.ConeGeometry(radius, height, 8);
                const cone = new THREE.Mesh(coneGeometry, leafMaterial);
                cone.position.set(0, yPos, 0);
                mainGroup.add(cone);
            }
            
            // æ ‘é¡¶æ˜Ÿæ˜Ÿ
            const starGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const starMaterial = new THREE.MeshStandardMaterial({
                color: 0xffdd00,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.set(0, 7, 0);
            mainGroup.add(star);
            
            // è£…é¥°çƒ
            const ballMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4444,
                roughness: 0.3,
                metalness: 0.7
            });
            
            const ballGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            
            // åœ¨æ ‘ä¸Šéšæœºæ”¾ç½®è£…é¥°çƒ
            for (let i = 0; i < 15; i++) {
                const ball = new THREE.Mesh(ballGeometry, ballMaterial);
                
                // éšæœºä½ç½®ï¼ˆåœ†é”¥å½¢åˆ†å¸ƒï¼‰
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 2;
                const height = Math.random() * 6;
                
                ball.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                mainGroup.add(ball);
            }
        }

        // ==================== æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ– ====================
        async function initHandDetection() {
            DEBUG.log('å¼€å§‹åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«');
            updateEngineStatus('åˆå§‹åŒ–ä¸­...');
            
            try {
                // è·å–DOMå…ƒç´ 
                videoElement = document.getElementById('camera-video');
                canvasElement = document.getElementById('camera-canvas');
                canvasCtx = canvasElement.getContext('2d');
                
                if (!videoElement || !canvasElement) {
                    throw new Error('æœªæ‰¾åˆ°æ‘„åƒå¤´å…ƒç´ ');
                }
                
                // è®¾ç½®Canvaså°ºå¯¸
                canvasElement.width = 140;
                canvasElement.height = 105;
                
                DEBUG.log('æ‘„åƒå¤´å…ƒç´ å‡†å¤‡å®Œæˆ');
                
                // ç­–ç•¥1ï¼šé¦–å…ˆå°è¯•MediaPipe
                try {
                    STATE.currentEngine = 'mediapipe';
                    await initMediaPipeWithTimeout();
                    updateEngineStatus('MediaPipe');
                    DEBUG.log('MediaPipeå¼•æ“åŠ è½½æˆåŠŸ', 'success');
                    return;
                } catch (mediaPipeError) {
                    DEBUG.log(`MediaPipeå¤±è´¥: ${mediaPipeError.message}`, 'error');
                }
                
                // ç­–ç•¥2ï¼šå¦‚æœMediaPipeå¤±è´¥ï¼Œå°è¯•Handtrack.js
                try {
                    STATE.currentEngine = 'handtrack';
                    await initHandTrackWithTimeout();
                    updateEngineStatus('Handtrack.js');
                    DEBUG.log('Handtrack.jså¼•æ“åŠ è½½æˆåŠŸ', 'success');
                    return;
                } catch (handTrackError) {
                    DEBUG.log(`Handtrack.jså¤±è´¥: ${handTrackError.message}`, 'error');
                }
                
                // ç­–ç•¥3ï¼šå¦‚æœä¸¤ä¸ªå¼•æ“éƒ½å¤±è´¥ï¼Œå¯ç”¨ç®€æ˜“æ‰‹åŠ¿æ¨¡å¼
                STATE.currentEngine = 'simple';
                initSimpleGestureMode();
                updateEngineStatus('ç®€æ˜“æ¨¡å¼');
                DEBUG.log('å¯ç”¨ç®€æ˜“æ‰‹åŠ¿æ¨¡å¼', 'success');
                
            } catch (error) {
                DEBUG.log(`æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å®Œå…¨å¤±è´¥: ${error.message}`, 'error');
                STATE.currentEngine = 'none';
                updateEngineStatus('æ— å¼•æ“');
                throw error;
            }
        }

        // MediaPipeåˆå§‹åŒ–ï¼ˆå¸¦è¶…æ—¶ï¼‰
        function initMediaPipeWithTimeout() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('MediaPipeåŠ è½½è¶…æ—¶'));
                }, CONFIG.gesture.mediaPipeTimeout);
                
                initMediaPipe().then(() => {
                    clearTimeout(timeout);
                    resolve();
                }).catch(error => {
                    clearTimeout(timeout);
                    reject(error);
                });
            });
        }

        async function initMediaPipe() {
            return new Promise(async (resolve, reject) => {
                try {
                    DEBUG.log('å¼€å§‹åŠ è½½MediaPipeåº“');
                    
                    // æ£€æŸ¥MediaPipeåº“æ˜¯å¦åŠ è½½
                    if (typeof window.FilesetResolver === 'undefined') {
                        reject(new Error('MediaPipeåº“æœªåŠ è½½'));
                        return;
                    }
                    
                    DEBUG.log('åˆ›å»ºMediaPipeè§£æå™¨');
                    
                    // åˆ›å»ºVisionä»»åŠ¡è§£æå™¨
                    const vision = await window.FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.2/wasm"
                    );
                    
                    DEBUG.log('åŠ è½½æ‰‹éƒ¨æ ‡è®°æ¨¡å‹');
                    
                    // åŠ è½½æ‰‹éƒ¨æ ‡è®°æ¨¡å‹
                    const handLandmarker = await window.HandLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                            delegate: "CPU" // ä½¿ç”¨CPUæ›´ç¨³å®š
                        },
                        runningMode: "VIDEO",
                        numHands: 1
                    });
                    
                    DEBUG.log('MediaPipeæ¨¡å‹åŠ è½½å®Œæˆ');
                    
                    // å­˜å‚¨æ£€æµ‹å™¨å¹¶å¯åŠ¨æ£€æµ‹
                    window.mediaPipeDetector = handLandmarker;
                    startMediaPipeDetection();
                    
                    resolve();
                    
                } catch (error) {
                    DEBUG.log(`MediaPipeåˆå§‹åŒ–é”™è¯¯: ${error.message}`, 'error');
                    reject(error);
                }
            });
        }

        function startMediaPipeDetection() {
            let lastVideoTime = -1;
            
            function detectFrame() {
                if (!STATE.cameraReady || !window.mediaPipeDetector || STATE.currentEngine !== 'mediapipe') {
                    return;
                }
                
                const currentTime = videoElement.currentTime;
                if (currentTime !== lastVideoTime) {
                    lastVideoTime = currentTime;
                    
                    try {
                        const results = window.mediaPipeDetector.detectForVideo(videoElement, performance.now());
                        processMediaPipeResults(results);
                    } catch (error) {
                        DEBUG.log(`MediaPipeæ£€æµ‹é”™è¯¯: ${error.message}`, 'error');
                    }
                }
                
                requestAnimationFrame(detectFrame);
            }
            
            detectFrame();
        }

        function processMediaPipeResults(results) {
            if (!results.landmarks || results.landmarks.length === 0) {
                STATE.handDetected = false;
                updateHandStatus('æœªæ£€æµ‹åˆ°æ‰‹éƒ¨');
                return;
            }
            
            STATE.handDetected = true;
            
            // ç®€åŒ–æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
            const landmarks = results.landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            
            // è®¡ç®—æ‹‡æŒ‡å’Œé£ŸæŒ‡è·ç¦»
            const pinchDist = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );
            
            // æ‰‹åŠ¿åˆ¤æ–­
            if (pinchDist < 0.05) {
                // æåˆæ‰‹åŠ¿ - åˆ‡æ¢åˆ°æ•£å¼€æ¨¡å¼
                if (STATE.mode !== 'SCATTER') {
                    STATE.mode = 'SCATTER';
                    updateHandStatus('ğŸ¤ æåˆ â†’ æ•£å¼€');
                }
            } else {
                // å¼ å¼€æ‰‹ - åˆ‡æ¢åˆ°æ ‘æ¨¡å¼
                if (STATE.mode !== 'TREE') {
                    STATE.mode = 'TREE';
                    updateHandStatus('ğŸ–ï¸ å¼ å¼€ â†’ åœ£è¯æ ‘');
                }
            }
        }

        // Handtrack.jsåˆå§‹åŒ–ï¼ˆå¸¦è¶…æ—¶ï¼‰
        function initHandTrackWithTimeout() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('Handtrack.jsåŠ è½½è¶…æ—¶'));
                }, CONFIG.gesture.handTrackTimeout);
                
                initHandTrack().then(() => {
                    clearTimeout(timeout);
                    resolve();
                }).catch(error => {
                    clearTimeout(timeout);
                    reject(error);
                });
            });
        }

        async function initHandTrack() {
            return new Promise(async (resolve, reject) => {
                try {
                    DEBUG.log('å¼€å§‹åŠ è½½Handtrack.jsåº“');
                    
                    // æ£€æŸ¥Handtrack.jsåº“æ˜¯å¦åŠ è½½
                    if (typeof handTrack === 'undefined') {
                        reject(new Error('Handtrack.jsåº“æœªåŠ è½½'));
                        return;
                    }
                    
                    DEBUG.log('åŠ è½½Handtrack.jsæ¨¡å‹');
                    
                    // åŠ è½½æ¨¡å‹
                    const modelParams = {
                        flipHorizontal: true,
                        maxNumBoxes: 1,
                        scoreThreshold: 0.7,
                        iouThreshold: 0.5
                    };
                    
                    window.handTrackModel = await handTrack.load(modelParams);
                    
                    DEBUG.log('Handtrack.jsæ¨¡å‹åŠ è½½å®Œæˆ');
                    
                    // å¯åŠ¨æ£€æµ‹
                    startHandTrackDetection();
                    
                    resolve();
                    
                } catch (error) {
                    DEBUG.log(`Handtrack.jsåˆå§‹åŒ–é”™è¯¯: ${error.message}`, 'error');
                    reject(error);
                }
            });
        }

        function startHandTrackDetection() {
            function detectFrame() {
                if (!STATE.cameraReady || !window.handTrackModel || STATE.currentEngine !== 'handtrack') {
                    return;
                }
                
                window.handTrackModel.detect(videoElement).then(predictions => {
                    processHandTrackResults(predictions);
                    
                    if (STATE.currentEngine === 'handtrack') {
                        requestAnimationFrame(detectFrame);
                    }
                }).catch(error => {
                    DEBUG.log(`Handtrack.jsæ£€æµ‹é”™è¯¯: ${error.message}`, 'error');
                    setTimeout(detectFrame, 1000);
                });
            }
            
            detectFrame();
        }

        function processHandTrackResults(predictions) {
            if (!predictions || predictions.length === 0) {
                STATE.handDetected = false;
                updateHandStatus('æœªæ£€æµ‹åˆ°æ‰‹éƒ¨');
                return;
            }
            
            STATE.handDetected = true;
            
            // ç®€åŒ–çš„æ‰‹åŠ¿åˆ¤æ–­ï¼ˆåŸºäºæ£€æµ‹æ¡†å¤§å°ï¼‰
            const bbox = predictions[0].bbox;
            const handArea = bbox[2] * bbox[3];
            
            // æ ¹æ®æ‰‹éƒ¨åŒºåŸŸåˆ¤æ–­æ‰‹åŠ¿
            if (handArea > 8000) {
                // å¤§æ‰‹åŠ¿ - åˆ‡æ¢åˆ°æ•£å¼€æ¨¡å¼
                if (STATE.mode !== 'SCATTER') {
                    STATE.mode = 'SCATTER';
                    updateHandStatus('ğŸ–ï¸ å¤§æ‰‹åŠ¿ â†’ æ•£å¼€');
                }
            } else if (handArea < 4000) {
                // å°æ‰‹åŠ¿ - åˆ‡æ¢åˆ°æ ‘æ¨¡å¼
                if (STATE.mode !== 'TREE') {
                    STATE.mode = 'TREE';
                    updateHandStatus('âœŠ å°æ‰‹åŠ¿ â†’ åœ£è¯æ ‘');
                }
            }
        }

        // ç®€æ˜“æ‰‹åŠ¿æ¨¡å¼
        function initSimpleGestureMode() {
            STATE.simpleMode = true;
            
            // é€šè¿‡æ‘„åƒå¤´å›¾åƒåˆ†æå®ç°ç®€æ˜“æ‰‹åŠ¿
            function simpleGestureDetection() {
                if (!STATE.cameraReady || STATE.currentEngine !== 'simple') {
                    return;
                }
                
                // ç»˜åˆ¶å½“å‰å¸§åˆ°Canvas
                canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                
                // è·å–å›¾åƒæ•°æ®
                const imageData = canvasCtx.getImageData(0, 0, canvasElement.width, canvasElement.height);
                const data = imageData.data;
                
                // ç®€åŒ–çš„æ‰‹åŠ¿æ£€æµ‹ï¼šåŸºäºå›¾åƒäº®åº¦å˜åŒ–
                let brightness = 0;
                for (let i = 0; i < data.length; i += 4) {
                    brightness += (data[i] + data[i + 1] + data[i + 2]) / 3;
                }
                brightness /= (data.length / 4);
                
                // å¦‚æœäº®åº¦æœ‰æ˜¾è‘—å˜åŒ–ï¼Œè®¤ä¸ºæ˜¯æ‰‹åŠ¿
                if (brightness > 100) { // é«˜äº®åº¦å¯èƒ½è¡¨ç¤ºæ‰‹é è¿‘
                    if (STATE.mode !== 'SCATTER') {
                        STATE.mode = 'SCATTER';
                        updateHandStatus('ğŸ‘ æ£€æµ‹åˆ°æ‰‹åŠ¿ â†’ æ•£å¼€');
                    }
                } else {
                    if (STATE.mode !== 'TREE') {
                        STATE.mode = 'TREE';
                        updateHandStatus('ğŸ‘ æ‰‹åŠ¿æ¶ˆå¤± â†’ åœ£è¯æ ‘');
                    }
                }
                
                requestAnimationFrame(simpleGestureDetection);
            }
            
            simpleGestureDetection();
            updateHandStatus('ç®€æ˜“æ‰‹åŠ¿æ¨¡å¼å·²å¯ç”¨');
        }

        // ==================== æ‘„åƒå¤´åˆå§‹åŒ– ====================
        async function setupCamera() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('æ‘„åƒå¤´åˆå§‹åŒ–è¶…æ—¶'));
                }, CONFIG.gesture.cameraTimeout);
                
                initializeCamera().then(() => {
                    clearTimeout(timeout);
                    resolve();
                }).catch(error => {
                    clearTimeout(timeout);
                    reject(error);
                });
            });
        }

        function initializeCamera() {
            return new Promise((resolve, reject) => {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    reject(new Error('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´'));
                    return;
                }
                
                DEBUG.log('è¯·æ±‚æ‘„åƒå¤´æƒé™');
                
                navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 320 },
                        height: { ideal: 240 }
                    },
                    audio: false
                }).then(stream => {
                    videoStream = stream;
                    videoElement.srcObject = stream;
                    
                    videoElement.onloadedmetadata = () => {
                        DEBUG.log('æ‘„åƒå¤´å·²å°±ç»ª', 'success');
                        STATE.cameraReady = true;
                        updateCameraStatus('å°±ç»ª');
                        resolve();
                    };
                    
                    videoElement.onerror = () => {
                        reject(new Error('è§†é¢‘æ’­æ”¾å¤±è´¥'));
                    };
                    
                }).catch(error => {
                    DEBUG.log(`æ‘„åƒå¤´è®¿é—®å¤±è´¥: ${error.message}`, 'error');
                    reject(error);
                });
            });
        }

        // ==================== UIæ›´æ–°å‡½æ•° ====================
        function updateEngineStatus(text) {
            const engineStatus = document.getElementById('engine-status');
            if (engineStatus) {
                const span = engineStatus.querySelector('span:last-child');
                if (span) {
                    span.textContent = `å¼•æ“: ${text}`;
                }
                
                // æ ¹æ®çŠ¶æ€æ”¹å˜é¢œè‰²
                if (text.includes('MediaPipe')) {
                    engineStatus.style.borderColor = 'rgba(66, 133, 244, 0.6)';
                } else if (text.includes('Handtrack')) {
                    engineStatus.style.borderColor = 'rgba(255, 107, 107, 0.6)';
                } else if (text.includes('ç®€æ˜“')) {
                    engineStatus.style.borderColor = 'rgba(78, 205, 196, 0.6)';
                } else {
                    engineStatus.style.borderColor = 'rgba(212, 175, 55, 0.3)';
                }
            }
        }

        function updateHandStatus(text) {
            const handStatus = document.getElementById('hand-status');
            if (handStatus) {
                const span = handStatus.querySelector('span:last-child');
                if (span) {
                    span.textContent = `æ‰‹åŠ¿: ${text}`;
                }
                
                // æ ¹æ®çŠ¶æ€æ”¹å˜é¢œè‰²
                if (text.includes('æœªæ£€æµ‹') || text.includes('ç­‰å¾…')) {
                    handStatus.style.borderColor = 'rgba(255, 107, 107, 0.3)';
                } else {
                    handStatus.style.borderColor = 'rgba(78, 205, 196, 0.6)';
                }
            }
        }

        function updateCameraStatus(text) {
            const cameraStatus = document.getElementById('camera-status');
            if (cameraStatus) {
                const span = cameraStatus.querySelector('span:last-child');
                if (span) {
                    span.textContent = `æ‘„åƒå¤´: ${text}`;
                }
                
                // æ ¹æ®çŠ¶æ€æ”¹å˜é¢œè‰²
                if (text === 'å°±ç»ª') {
                    cameraStatus.style.borderColor = 'rgba(78, 205, 196, 0.6)';
                } else {
                    cameraStatus.style.borderColor = 'rgba(212, 175, 55, 0.3)';
                }
            }
        }

        function showFixButton(text) {
            const fixBtn = document.getElementById('fix-btn');
            if (fixBtn) {
                fixBtn.textContent = text;
                fixBtn.style.display = 'block';
            }
        }

        function hideFixButton() {
            const fixBtn = document.getElementById('fix-btn');
            if (fixBtn) {
                fixBtn.style.display = 'none';
            }
        }

        // ==================== UIäº‹ä»¶å¤„ç† ====================
        function setupUIEvents() {
            // æ§åˆ¶æŒ‰é’®
            document.getElementById('btn-tree').addEventListener('click', () => {
                STATE.mode = 'TREE';
                DEBUG.log('æ‰‹åŠ¨åˆ‡æ¢åˆ°åœ£è¯æ ‘æ¨¡å¼');
            });
            
            document.getElementById('btn-scatter').addEventListener('click', () => {
                STATE.mode = 'SCATTER';
                DEBUG.log('æ‰‹åŠ¨åˆ‡æ¢åˆ°æ•£å¼€æ¨¡å¼');
            });
            
            document.getElementById('btn-toggle-debug').addEventListener('click', () => {
                DEBUG.enabled = !DEBUG.enabled;
                if (DEBUG.enabled) {
                    DEBUG.showPanel();
                    DEBUG.log('è°ƒè¯•æ¨¡å¼å·²å¼€å¯');
                } else {
                    DEBUG.hidePanel();
                }
            });
            
            document.getElementById('btn-simple-mode').addEventListener('click', () => {
                if (STATE.currentEngine !== 'simple') {
                    STATE.currentEngine = 'simple';
                    initSimpleGestureMode();
                    DEBUG.log('æ‰‹åŠ¨åˆ‡æ¢åˆ°ç®€æ˜“æ‰‹åŠ¿æ¨¡å¼');
                }
            });
            
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
            
            // ä¿®å¤æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            document.getElementById('fix-btn').addEventListener('click', forceRetryHandDetection);
        }

        function forceRetryHandDetection() {
            DEBUG.log('æ‰‹åŠ¨é‡è¯•æ‰‹åŠ¿è¯†åˆ«');
            hideFixButton();
            
            // é‡ç½®çŠ¶æ€
            STATE.currentEngine = null;
            STATE.retryCount = 0;
            
            // æ¸…ç†ç°æœ‰å¼•æ“
            if (window.mediaPipeDetector) {
                window.mediaPipeDetector.close();
                window.mediaPipeDetector = null;
            }
            
            if (window.handTrackModel) {
                window.handTrackModel.dispose();
                window.handTrackModel = null;
            }
            
            // é‡æ–°åˆå§‹åŒ–
            initHandDetection().catch(error => {
                DEBUG.log(`é‡è¯•å¤±è´¥: ${error.message}`, 'error');
                showFixButton('é‡è¯•å¤±è´¥ï¼Œç‚¹å‡»å†æ¬¡å°è¯•');
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            
            // æ ¹æ®æ¨¡å¼æ—‹è½¬åœºæ™¯
            if (STATE.mode === 'TREE') {
                mainGroup.rotation.y += 0.2 * dt;
            } else if (STATE.mode === 'SCATTER') {
                mainGroup.rotation.x += 0.1 * dt;
                mainGroup.rotation.y += 0.15 * dt;
            }
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }

        // ==================== å¯åŠ¨åº”ç”¨ ====================
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            // æ›´æ–°åŠ è½½æ–‡æœ¬
            const loaderText = document.getElementById('loader-text');
            if (loaderText) {
                const texts = [
                    'åˆå§‹åŒ–ä¸­...',
                    'åŠ è½½3Då¼•æ“...',
                    'å‡†å¤‡æ‰‹åŠ¿è¯†åˆ«...',
                    'å³å°†å®Œæˆ...'
                ];
                let index = 0;
                
                setInterval(() => {
                    loaderText.textContent = texts[index];
                    index = (index + 1) % texts.length;
                }, 1500);
            }
            
            // å»¶è¿Ÿåˆå§‹åŒ–ä»¥é¿å…é˜»å¡
            setTimeout(init, 500);
        });
        
        // åŠ è½½è¶…æ—¶å¤„ç†
        setTimeout(() => {
            const loader = document.getElementById('loader');
            if (loader && loader.style.display !== 'none') {
                showFixButton('åŠ è½½æ—¶é—´è¿‡é•¿ï¼Œç‚¹å‡»é‡è¯•');
            }
        }, 15000);
    </script>
</body>
</html>
