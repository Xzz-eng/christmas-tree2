<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>3Dåœ£è¯æ ‘ - æ‰‹åŠ¿æ§åˆ¶ä¼˜åŒ–ç‰ˆ</title>
    
    <!-- å¼•å…¥Three.jså’Œç›¸å…³åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/environments/RoomEnvironment.js"></script>
    
    <!-- å¼•å…¥MediaPipe Hand Landmarker -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.js"></script>

    <style>
        :root {
            --safe-area-inset-top: env(safe-area-inset-top, 0px);
            --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            box-sizing: border-box;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
            position: fixed;
            width: 100vw;
            height: 100vh;
            touch-action: none;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            margin-top: calc(env(safe-area-inset-top) * -1);
            margin-bottom: calc(env(safe-area-inset-bottom) * -1);
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* åŠ è½½ç•Œé¢ */
        #loader {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100vw; 
            height: 100vh;
            background: #000; 
            z-index: 100;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            transition: opacity 0.8s ease-out;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .loader-text {
            color: #d4af37; 
            font-size: 14px; 
            letter-spacing: 2px; 
            margin-top: 20px;
            text-transform: uppercase; 
            font-weight: 300;
            text-align: center;
            padding: 0 20px;
        }
        
        .spinner {
            width: 30px; 
            height: 30px; 
            border: 1px solid rgba(212, 175, 55, 0.2); 
            border-top: 1px solid #d4af37; 
            border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        
        /* æ‰‹åŠ¿æ§åˆ¶ç•Œé¢ */
        .gesture-controls {
            position: fixed;
            top: calc(15px + env(safe-area-inset-top));
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(212, 175, 55, 0.4);
            border-radius: 12px;
            padding: 12px;
            z-index: 20;
            backdrop-filter: blur(10px);
            color: #d4af37;
            max-width: 300px;
        }
        
        .gesture-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .gesture-list {
            font-size: 11px;
            line-height: 1.5;
            color: rgba(212, 175, 55, 0.8);
        }
        
        .gesture-item {
            margin: 4px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .gesture-icon {
            font-size: 12px;
            width: 16px;
            text-align: center;
        }
        
        /* æ‘„åƒå¤´ç•Œé¢ */
        .camera-container {
            position: fixed;
            bottom: calc(15px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: 140px;
            height: 105px;
            border-radius: 8px;
            overflow: hidden;
            z-index: 15;
            border: 2px solid rgba(212, 175, 55, 0.3);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
            transition: all 0.3s ease;
            background: #000;
        }
        
        .camera-container.active {
            border-color: #d4af37;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.4);
        }
        
        #camera-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
        }
        
        #camera-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* æ‰‹åŠ¿æ£€æµ‹è°ƒè¯•ä¿¡æ¯ */
        .debug-info {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: #4ecdc4;
            font-size: 9px;
            padding: 4px 8px;
            border-radius: 4px;
            display: none; /* é»˜è®¤éšè—ï¼Œè°ƒè¯•æ—¶å¯æ˜¾ç¤º */
        }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-indicator {
            position: fixed;
            top: calc(15px + env(safe-area-inset-top));
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: #d4af37;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
        
        .status-icon {
            font-size: 14px;
        }
        
        .hand-status {
            position: fixed;
            bottom: calc(125px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #d4af37;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 20;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.3);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            position: fixed;
            bottom: calc(15px + env(safe-area-inset-bottom));
            left: 15px;
            display: flex;
            gap: 10px;
            z-index: 20;
        }
        
        .control-btn {
            background: rgba(30, 30, 30, 0.7);
            border: 1px solid rgba(212, 175, 55, 0.4);
            color: #d4af37;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            touch-action: manipulation;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .control-btn:active {
            background: rgba(212, 175, 55, 0.3);
            transform: scale(0.95);
        }
        
        .control-btn.active {
            background: rgba(212, 175, 55, 0.2);
            border-color: #d4af37;
        }
        
        /* æ‰‹åŠ¿æ ¡å‡†ç•Œé¢ */
        .calibration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
        }
        
        .calibration-content {
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #d4af37;
            border-radius: 15px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
        }
        
        .calibration-title {
            color: #d4af37;
            font-size: 20px;
            margin-bottom: 15px;
        }
        
        .calibration-step {
            color: #aaa;
            font-size: 14px;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .calibration-btn {
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid #d4af37;
            color: #d4af37;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            width: 100%;
        }
        
        .calibration-btn:active {
            background: rgba(212, 175, 55, 0.4);
        }
        
        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            .gesture-controls {
                max-width: 250px;
                font-size: 10px;
            }
            
            .gesture-list {
                font-size: 10px;
            }
            
            .camera-container {
                width: 120px;
                height: 90px;
            }
            
            .control-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
        }
        
        @media (max-height: 700px) {
            .gesture-controls {
                top: 10px;
                left: 10px;
                padding: 8px;
            }
            
            .camera-container {
                bottom: 10px;
                width: 100px;
                height: 75px;
            }
            
            .hand-status {
                bottom: 95px;
            }
            
            .control-panel {
                bottom: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«...</div>
    </div>
    
    <!-- æ‰‹åŠ¿æ ¡å‡†ç•Œé¢ -->
    <div class="calibration-overlay" id="calibration-overlay">
        <div class="calibration-content">
            <div class="calibration-title">æ‰‹åŠ¿æ ¡å‡†</div>
            <div class="calibration-step" id="calibration-step">
                è¯·å°†æ‰‹æ”¾åœ¨æ‘„åƒå¤´å‰ï¼Œç¡®ä¿æ‰‹éƒ¨å®Œå…¨å¯è§
            </div>
            <div id="calibration-progress"></div>
            <button class="calibration-btn" id="start-calibration">å¼€å§‹æ ¡å‡†</button>
            <button class="calibration-btn" onclick="skipCalibration()" style="background: rgba(255,255,255,0.1); margin-top: 10px;">
                è·³è¿‡æ ¡å‡†
            </button>
        </div>
    </div>

    <div id="canvas-container"></div>
    
    <!-- æ‰‹åŠ¿æ§åˆ¶è¯´æ˜ -->
    <div class="gesture-controls">
        <div class="gesture-title">
            <span>ğŸ‘‹</span>
            <span>æ‰‹åŠ¿æ§åˆ¶æŒ‡å—</span>
        </div>
        <div class="gesture-list">
            <div class="gesture-item">
                <span class="gesture-icon">âœŠ</span>
                <span>æ¡æ‹³ - å›åˆ°åœ£è¯æ ‘å½¢æ€</span>
            </div>
            <div class="gesture-item">
                <span class="gesture-icon">ğŸ–ï¸</span>
                <span>å¼ å¼€æ‰‹ - è¿›å…¥æ•£å¼€å½¢æ€</span>
            </div>
            <div class="gesture-item">
                <span class="gesture-icon">ğŸ¤</span>
                <span>æåˆï¼ˆæ‹‡æŒ‡+é£ŸæŒ‡ï¼‰- æ”¾å¤§ç…§ç‰‡</span>
            </div>
            <div class="gesture-item">
                <span class="gesture-icon">ğŸ”„</span>
                <span>æ‰‹ç§»åŠ¨ - æ—‹è½¬åœºæ™¯</span>
            </div>
        </div>
    </div>
    
    <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
    <div class="status-indicator" id="status-indicator">
        <span class="status-icon">ğŸ„</span>
        <span id="mode-text">åœ£è¯æ ‘å½¢æ€</span>
    </div>
    
    <!-- æ‘„åƒå¤´é¢„è§ˆ -->
    <div class="camera-container" id="camera-container">
        <video id="camera-video" autoplay playsinline></video>
        <canvas id="camera-canvas"></canvas>
        <div class="debug-info" id="debug-info"></div>
    </div>
    
    <!-- æ‰‹åŠ¿çŠ¶æ€ -->
    <div class="hand-status" id="hand-status">
        <span>ğŸ‘‹</span>
        <span id="hand-text">ç­‰å¾…æ‰‹åŠ¿...</span>
    </div>
    
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <div class="control-btn" id="btn-tree" title="åœ£è¯æ ‘å½¢æ€">ğŸ„</div>
        <div class="control-btn" id="btn-scatter" title="æ•£å¼€å½¢æ€">âœ¨</div>
        <div class="control-btn" id="btn-focus" title="éšæœºèšç„¦ç…§ç‰‡">ğŸ“¸</div>
        <div class="control-btn" id="btn-calibrate" title="é‡æ–°æ ¡å‡†æ‰‹åŠ¿">ğŸ¯</div>
    </div>

    <script>
        // æ£€æµ‹è®¾å¤‡ç±»å‹
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIPhone = /iPhone/i.test(navigator.userAgent);
        
        // é…ç½®
        const CONFIG = {
            colors: {
                bg: 0x000000, 
                champagneGold: 0xffd966, 
                deepGreen: 0x03180a,     
                accentRed: 0x990000,     
            },
            particles: {
                count: isMobile ? 200 : 400,  // è¿›ä¸€æ­¥å‡å°‘ç²’å­æ•°ä»¥æé«˜æ€§èƒ½
                dustCount: isMobile ? 400 : 800,
                treeHeight: 16,  
                treeRadius: 4    
            },
            camera: {
                z: isMobile ? 22 : 35
            },
            gesture: {
                // æ‰‹åŠ¿è¯†åˆ«é˜ˆå€¼ - ä¼˜åŒ–åçš„å€¼
                fistThreshold: 0.12,      // æ¡æ‹³é˜ˆå€¼ï¼ˆé™ä½ï¼‰
                openHandThreshold: 0.3,   // å¼ å¼€æ‰‹é˜ˆå€¼ï¼ˆæé«˜ï¼‰
                pinchThreshold: 0.08,     // æåˆé˜ˆå€¼ï¼ˆæé«˜ï¼‰
                rotationSensitivity: 3.0, // æ—‹è½¬çµæ•åº¦ï¼ˆæé«˜ï¼‰
                smoothFactor: 0.2,        // å¹³æ»‘ç³»æ•°ï¼ˆé™ä½ï¼‰
                
                // æ‰‹åŠ¿ç¨³å®šæ€§è®¾ç½®
                gestureBufferSize: 5,     // æ‰‹åŠ¿ç¼“å†²åŒºå¤§å°
                gestureConfidence: 0.7,   // æ‰‹åŠ¿ç½®ä¿¡åº¦
                
                // æåˆæ‰‹åŠ¿ä¼˜åŒ–
                pinchMinDistance: 0.05,   // æœ€å°æåˆè·ç¦»
                pinchMaxDistance: 0.15    // æœ€å¤§æåˆè·ç¦»
            }
        };

        // åº”ç”¨çŠ¶æ€
        const STATE = {
            mode: 'TREE', // TREE, SCATTER, FOCUS
            focusTarget: null,
            transitionProgress: 0,
            
            // æ‰‹åŠ¿çŠ¶æ€
            hand: {
                detected: false,
                landmarks: null,
                position: { x: 0, y: 0 },
                gesture: 'NONE', // NONE, FIST, OPEN, PINCH, ROTATE
                rotation: { x: 0, y: 0 },
                pinchStrength: 0,
                history: [],
                gestureHistory: [], // æ‰‹åŠ¿å†å²è®°å½•
                calibration: {
                    isCalibrating: false,
                    fistSamples: [],
                    openSamples: [],
                    pinchSamples: []
                }
            },
            
            // ç›¸æœºæ§åˆ¶
            rotation: { x: 0, y: 0 },
            autoRotate: true,
            
            // ç³»ç»ŸçŠ¶æ€
            cameraEnabled: false,
            handDetector: null,
            videoStream: null,
            lastGestureTime: 0,
            gestureCooldown: 500 // æ‰‹åŠ¿å†·å´æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        };

        // Three.jså˜é‡
        let scene, camera, renderer, composer;
        let mainGroup; 
        let clock = new THREE.Clock();
        let particleSystem = []; 
        let photoMeshGroup = new THREE.Group();
        let caneTexture;

        // MediaPipeå˜é‡
        let handLandmarker;
        let videoElement, canvasElement, canvasCtx;
        let lastVideoTime = -1;

        // åˆå§‹åŒ–å‡½æ•°
        async function init() {
            try {
                initThree();
                setupEnvironment();
                setupLights();
                createTextures();
                createParticles();
                createDust();
                createDefaultPhotos();
                setupPostProcessing();
                setupUIEvents();
                
                // æ˜¾ç¤ºæ ¡å‡†ç•Œé¢
                showCalibrationOverlay();
                
                // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
                await initHandDetection();
                
                // éšè—åŠ è½½ç•Œé¢
                const loader = document.getElementById('loader');
                if (loader) {
                    setTimeout(() => {
                        loader.style.opacity = 0;
                        setTimeout(() => {
                            loader.style.display = 'none';
                        }, 800);
                    }, 1000);
                }

                updateStatusIndicator();
                animate();
            } catch (error) {
                console.error('åˆå§‹åŒ–é”™è¯¯:', error);
                showDebugInfo('åˆå§‹åŒ–å¤±è´¥: ' + error.message);
            }
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, CONFIG.camera.z);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: false, 
                powerPreference: "high-performance",
                precision: 'mediump'
            });
            
            renderer.setPixelRatio(isMobile ? 1.5 : 1.5);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.8;
            renderer.shadowMap.enabled = false;
            container.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }

        function setupEnvironment() {
            try {
                if (typeof THREE.RoomEnvironment !== 'undefined') {
                    const pmremGenerator = new THREE.PMREMGenerator(renderer);
                    scene.environment = pmremGenerator.fromScene(new THREE.RoomEnvironment(), 0.04).texture;
                }
            } catch (error) {
                console.warn('ç¯å¢ƒè®¾ç½®å¤±è´¥:', error);
            }
            
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
        }

        function setupLights() {
            const innerLight = new THREE.PointLight(0xffaa00, 1.0, 10);
            innerLight.position.set(0, 4, 0);
            mainGroup.add(innerLight);

            const spotGold = new THREE.SpotLight(0xffcc66, 400);
            spotGold.position.set(10, 20, 20);
            spotGold.angle = 0.3;
            spotGold.penumbra = 0.5;
            scene.add(spotGold);
        }

        function setupPostProcessing() {
            if (isMobile || typeof THREE.EffectComposer === 'undefined') return;
            
            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight), 
                    0.8, 0.4, 0.8
                );

                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
            } catch (error) {
                console.warn('åæœŸå¤„ç†è®¾ç½®å¤±è´¥:', error);
            }
        }

        // æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–
        async function initHandDetection() {
            try {
                videoElement = document.getElementById('camera-video');
                canvasElement = document.getElementById('camera-canvas');
                canvasCtx = canvasElement.getContext('2d');
                
                // è®¾ç½®canvaså°ºå¯¸
                canvasElement.width = 140;
                canvasElement.height = 105;
                
                // è¯·æ±‚ç›¸æœºæƒé™
                await requestCameraPermission();
                
                // åˆå§‹åŒ–MediaPipe Hand Landmarker
                const vision = await window.FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                handLandmarker = await window.HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 2, // å¢åŠ æ‰‹éƒ¨æ£€æµ‹æ•°é‡
                    minHandDetectionConfidence: 0.5,
                    minHandPresenceConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                // å¼€å§‹è§†é¢‘æµå¤„ç†
                startVideoProcessing();
                
                updateHandStatus('ç­‰å¾…æ‰‹åŠ¿...');
                
            } catch (error) {
                console.error('æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥:', error);
                updateHandStatus('æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥');
                showDebugInfo('æ‰‹åŠ¿è¯†åˆ«å¤±è´¥: ' + error.message);
            }
        }

        async function requestCameraPermission() {
            return new Promise((resolve, reject) => {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    reject(new Error('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®'));
                    return;
                }
                
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 30 }
                    }
                };
                
                navigator.mediaDevices.getUserMedia(constraints)
                    .then(stream => {
                        STATE.videoStream = stream;
                        videoElement.srcObject = stream;
                        STATE.cameraEnabled = true;
                        
                        document.getElementById('camera-container').classList.add('active');
                        
                        videoElement.onloadedmetadata = () => {
                            videoElement.play();
                            resolve();
                        };
                    })
                    .catch(error => {
                        console.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥:', error);
                        reject(error);
                    });
            });
        }

        function startVideoProcessing() {
            function processFrame() {
                if (!STATE.cameraEnabled || !handLandmarker || videoElement.readyState < 2) {
                    requestAnimationFrame(processFrame);
                    return;
                }
                
                const startTimeMs = performance.now();
                
                if (lastVideoTime !== videoElement.currentTime) {
                    lastVideoTime = videoElement.currentTime;
                    
                    try {
                        // æ£€æµ‹æ‰‹åŠ¿
                        const results = handLandmarker.detectForVideo(videoElement, startTimeMs);
                        processHandResults(results);
                        
                        // åœ¨canvasä¸Šç»˜åˆ¶ç»“æœ
                        drawHandLandmarks(results);
                    } catch (error) {
                        console.error('æ‰‹åŠ¿å¤„ç†é”™è¯¯:', error);
                    }
                }
                
                requestAnimationFrame(processFrame);
            }
            
            processFrame();
        }

        function processHandResults(results) {
            if (!results || !results.landmarks || results.landmarks.length === 0) {
                STATE.hand.detected = false;
                STATE.hand.gesture = 'NONE';
                updateHandStatus('æœªæ£€æµ‹åˆ°æ‰‹éƒ¨');
                return;
            }
            
            STATE.hand.detected = true;
            const landmarks = results.landmarks[0];
            STATE.hand.landmarks = landmarks;
            
            // è®¡ç®—æ‰‹åŠ¿
            const gesture = recognizeGesture(landmarks);
            
            // æ·»åŠ æ‰‹åŠ¿åˆ°å†å²è®°å½•
            STATE.hand.gestureHistory.push(gesture);
            if (STATE.hand.gestureHistory.length > CONFIG.gesture.gestureBufferSize) {
                STATE.hand.gestureHistory.shift();
            }
            
            // ä»å†å²è®°å½•ä¸­ç¡®å®šæœ€é¢‘ç¹çš„æ‰‹åŠ¿
            const gestureCount = {};
            STATE.hand.gestureHistory.forEach(g => {
                gestureCount[g] = (gestureCount[g] || 0) + 1;
            });
            
            let finalGesture = 'NONE';
            let maxCount = 0;
            for (const [g, count] of Object.entries(gestureCount)) {
                if (count > maxCount) {
                    maxCount = count;
                    finalGesture = g;
                }
            }
            
            // åªæœ‰è¾¾åˆ°ç½®ä¿¡åº¦é˜ˆå€¼æ‰æ›´æ–°æ‰‹åŠ¿
            const confidence = maxCount / STATE.hand.gestureHistory.length;
            if (confidence >= CONFIG.gesture.gestureConfidence) {
                STATE.hand.gesture = finalGesture;
            }
            
            // æ›´æ–°æ‰‹åŠ¿çŠ¶æ€æ˜¾ç¤º
            updateHandStatus(getGestureText(STATE.hand.gesture));
            
            // æ ¹æ®æ‰‹åŠ¿æ›´æ–°åº”ç”¨çŠ¶æ€
            handleGesture(STATE.hand.gesture, landmarks);
        }

        function recognizeGesture(landmarks) {
            // è·å–å…³é”®ç‚¹ç´¢å¼•
            const WRIST = 0;
            const THUMB_CMC = 1;
            const THUMB_MCP = 2;
            const THUMB_IP = 3;
            const THUMB_TIP = 4;
            const INDEX_FINGER_MCP = 5;
            const INDEX_FINGER_PIP = 6;
            const INDEX_FINGER_DIP = 7;
            const INDEX_FINGER_TIP = 8;
            const MIDDLE_FINGER_MCP = 9;
            const MIDDLE_FINGER_PIP = 10;
            const MIDDLE_FINGER_DIP = 11;
            const MIDDLE_FINGER_TIP = 12;
            const RING_FINGER_MCP = 13;
            const RING_FINGER_PIP = 14;
            const RING_FINGER_DIP = 15;
            const RING_FINGER_TIP = 16;
            const PINKY_MCP = 17;
            const PINKY_PIP = 18;
            const PINKY_DIP = 19;
            const PINKY_TIP = 20;
            
            // è®¡ç®—æ‰‹æŒ‡å¼¯æ›²åº¦
            const calculateFingerBend = (tip, pip, mcp) => {
                const tipToPip = distance(tip, pip);
                const pipToMcp = distance(pip, mcp);
                return tipToPip / pipToMcp;
            };
            
            // è®¡ç®—ä¸¤ç‚¹è·ç¦»
            const distance = (p1, p2) => {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                const dz = p1.z - p2.z;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            };
            
            // è®¡ç®—æ‰€æœ‰æ‰‹æŒ‡çš„å¼¯æ›²åº¦
            const thumbBend = calculateFingerBend(
                landmarks[THUMB_TIP],
                landmarks[THUMB_IP],
                landmarks[THUMB_MCP]
            );
            
            const indexBend = calculateFingerBend(
                landmarks[INDEX_FINGER_TIP],
                landmarks[INDEX_FINGER_PIP],
                landmarks[INDEX_FINGER_MCP]
            );
            
            const middleBend = calculateFingerBend(
                landmarks[MIDDLE_FINGER_TIP],
                landmarks[MIDDLE_FINGER_PIP],
                landmarks[MIDDLE_FINGER_MCP]
            );
            
            const ringBend = calculateFingerBend(
                landmarks[RING_FINGER_TIP],
                landmarks[RING_FINGER_PIP],
                landmarks[RING_FINGER_MCP]
            );
            
            const pinkyBend = calculateFingerBend(
                landmarks[PINKY_TIP],
                landmarks[PINKY_PIP],
                landmarks[PINKY_MCP]
            );
            
            // è®¡ç®—æŒ‡å°–åˆ°æ‰‹æŒçš„è·ç¦»
            const palmCenter = {
                x: (landmarks[WRIST].x + landmarks[MIDDLE_FINGER_MCP].x) / 2,
                y: (landmarks[WRIST].y + landmarks[MIDDLE_FINGER_MCP].y) / 2,
                z: (landmarks[WRIST].z + landmarks[MIDDLE_FINGER_MCP].z) / 2
            };
            
            const thumbToPalm = distance(landmarks[THUMB_TIP], palmCenter);
            const indexToPalm = distance(landmarks[INDEX_FINGER_TIP], palmCenter);
            const middleToPalm = distance(landmarks[MIDDLE_FINGER_TIP], palmCenter);
            const ringToPalm = distance(landmarks[RING_FINGER_TIP], palmCenter);
            const pinkyToPalm = distance(landmarks[PINKY_TIP], palmCenter);
            
            const avgFingerToPalm = (indexToPalm + middleToPalm + ringToPalm + pinkyToPalm) / 4;
            
            // è®¡ç®—æåˆè·ç¦»ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡ï¼‰
            const pinchDistance = distance(landmarks[THUMB_TIP], landmarks[INDEX_FINGER_TIP]);
            STATE.hand.pinchStrength = 1 - Math.min(pinchDistance * 5, 1);
            
            // æ£€æµ‹æ¡æ‹³ï¼ˆæ‰€æœ‰æ‰‹æŒ‡éƒ½å¼¯æ›²ï¼‰
            const isFist = thumbBend < 0.5 && indexBend < 0.5 && middleBend < 0.5 && 
                          ringBend < 0.5 && pinkyBend < 0.5 && avgFingerToPalm < CONFIG.gesture.fistThreshold;
            
            // æ£€æµ‹å¼ å¼€æ‰‹ï¼ˆæ‰‹æŒ‡éƒ½ä¼¸ç›´ï¼‰
            const isOpen = indexBend > 0.7 && middleBend > 0.7 && ringBend > 0.7 && 
                          pinkyBend > 0.7 && avgFingerToPalm > CONFIG.gesture.openHandThreshold;
            
            // æ£€æµ‹æåˆï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡é è¿‘ï¼Œå…¶ä»–æ‰‹æŒ‡å¼¯æ›²ï¼‰
            const isPinch = pinchDistance < CONFIG.gesture.pinchThreshold && 
                          pinchDistance > CONFIG.gesture.pinchMinDistance &&
                          middleBend < 0.5 && ringBend < 0.5 && pinkyBend < 0.5;
            
            // æ£€æµ‹æ‰‹éƒ¨ç§»åŠ¨ï¼ˆç”¨äºæ—‹è½¬æ§åˆ¶ï¼‰
            const wrist = landmarks[WRIST];
            if (STATE.hand.position.x !== 0 && STATE.hand.position.y !== 0) {
                const deltaX = wrist.x - STATE.hand.position.x;
                const deltaY = wrist.y - STATE.hand.position.y;
                
                if (Math.abs(deltaX) > 0.01 || Math.abs(deltaY) > 0.01) {
                    STATE.hand.rotation.x = deltaY * CONFIG.gesture.rotationSensitivity;
                    STATE.hand.rotation.y = deltaX * CONFIG.gesture.rotationSensitivity;
                }
            }
            
            // æ›´æ–°æ‰‹çš„ä½ç½®
            STATE.hand.position.x = wrist.x;
            STATE.hand.position.y = wrist.y;
            
            // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
            showDebugInfo(`æ¡æ‹³: ${isFist ? 'æ˜¯' : 'å¦'} | å¼ å¼€: ${isOpen ? 'æ˜¯' : 'å¦'} | æåˆ: ${isPinch ? 'æ˜¯' : 'å¦'} (${pinchDistance.toFixed(3)})`);
            
            // ç¡®å®šæ‰‹åŠ¿ä¼˜å…ˆçº§
            if (isFist) return 'FIST';
            if (isPinch) return 'PINCH';
            if (isOpen) return 'OPEN';
            if (Math.abs(STATE.hand.rotation.x) > 0.05 || Math.abs(STATE.hand.rotation.y) > 0.05) return 'ROTATE';
            
            return 'NONE';
        }

        function handleGesture(gesture, landmarks) {
            // æ‰‹åŠ¿å†·å´æ—¶é—´æ£€æŸ¥
            const now = Date.now();
            if (now - STATE.lastGestureTime < STATE.gestureCooldown) {
                return;
            }
            
            switch (gesture) {
                case 'FIST':
                    // æ¡æ‹³ï¼šå›åˆ°åœ£è¯æ ‘å½¢æ€
                    if (STATE.mode !== 'TREE') {
                        STATE.mode = 'TREE';
                        STATE.focusTarget = null;
                        STATE.autoRotate = true;
                        STATE.lastGestureTime = now;
                        updateStatusIndicator();
                        showDebugInfo('æ‰‹åŠ¿ï¼šæ¡æ‹³ -> åœ£è¯æ ‘å½¢æ€');
                    }
                    break;
                    
                case 'OPEN':
                    // å¼ å¼€æ‰‹ï¼šè¿›å…¥æ•£å¼€å½¢æ€
                    if (STATE.mode !== 'SCATTER') {
                        STATE.mode = 'SCATTER';
                        STATE.focusTarget = null;
                        STATE.autoRotate = false;
                        STATE.lastGestureTime = now;
                        updateStatusIndicator();
                        showDebugInfo('æ‰‹åŠ¿ï¼šå¼ å¼€æ‰‹ -> æ•£å¼€å½¢æ€');
                    }
                    break;
                    
                case 'PINCH':
                    // æåˆï¼šæ”¾å¤§ç…§ç‰‡
                    if (STATE.mode === 'SCATTER' && !STATE.focusTarget) {
                        const photos = particleSystem.filter(p => p.type === 'PHOTO');
                        if (photos.length > 0) {
                            STATE.mode = 'FOCUS';
                            // é€‰æ‹©æœ€é è¿‘å±å¹•ä¸­å¿ƒçš„ç…§ç‰‡
                            const center = new THREE.Vector3(0, 0, 0);
                            let closestPhoto = null;
                            let minDistance = Infinity;
                            
                            photos.forEach(p => {
                                const distance = p.mesh.position.distanceTo(center);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestPhoto = p;
                                }
                            });
                            
                            STATE.focusTarget = closestPhoto.mesh;
                            STATE.lastGestureTime = now;
                            updateStatusIndicator();
                            showDebugInfo('æ‰‹åŠ¿ï¼šæåˆ -> æ”¾å¤§ç…§ç‰‡');
                        }
                    }
                    break;
                    
                case 'ROTATE':
                    // æ—‹è½¬ï¼šæ§åˆ¶åœºæ™¯æ—‹è½¬
                    STATE.autoRotate = false;
                    const smoothFactor = CONFIG.gesture.smoothFactor;
                    STATE.rotation.x += (STATE.hand.rotation.x - STATE.rotation.x) * smoothFactor;
                    STATE.rotation.y += (STATE.hand.rotation.y - STATE.rotation.y) * smoothFactor;
                    
                    // é™åˆ¶æ—‹è½¬è§’åº¦
                    STATE.rotation.x = Math.max(-1, Math.min(1, STATE.rotation.x));
                    STATE.rotation.y = Math.max(-1, Math.min(1, STATE.rotation.y));
                    break;
            }
            
            // é€æ¸é‡ç½®æ—‹è½¬å€¼
            STATE.hand.rotation.x *= 0.9;
            STATE.hand.rotation.y *= 0.9;
        }

        function drawHandLandmarks(results) {
            if (!results.landmarks || results.landmarks.length === 0) {
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                return;
            }
            
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.save();
            
            // é•œåƒç¿»è½¬canvas
            canvasCtx.scale(-1, 1);
            canvasCtx.translate(-canvasElement.width, 0);
            
            // ç»˜åˆ¶è§†é¢‘å¸§
            canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
            
            // ç»˜åˆ¶æ‰‹åŠ¿è¯†åˆ«ç»“æœ
            const landmarks = results.landmarks[0];
            const connections = window.HAND_CONNECTIONS || [];
            
            // ç»˜åˆ¶è¿æ¥çº¿
            canvasCtx.strokeStyle = '#00ff00';
            canvasCtx.lineWidth = 2;
            
            connections.forEach(connection => {
                const [start, end] = connection;
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                canvasCtx.beginPath();
                canvasCtx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
                canvasCtx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
                canvasCtx.stroke();
            });
            
            // ç»˜åˆ¶å…³é”®ç‚¹ï¼ˆä¸åŒæ‰‹åŠ¿ä¸åŒé¢œè‰²ï¼‰
            landmarks.forEach((landmark, index) => {
                let color = '#ff0000';
                
                // æ ¹æ®æ‰‹åŠ¿çŠ¶æ€æ”¹å˜å…³é”®ç‚¹é¢œè‰²
                switch(STATE.hand.gesture) {
                    case 'FIST':
                        color = '#ff4444'; // çº¢è‰²
                        break;
                    case 'OPEN':
                        color = '#44ff44'; // ç»¿è‰²
                        break;
                    case 'PINCH':
                        color = '#4444ff'; // è“è‰²
                        break;
                    case 'ROTATE':
                        color = '#ffff44'; // é»„è‰²
                        break;
                }
                
                // æ‹‡æŒ‡å’Œé£ŸæŒ‡æŒ‡å°–ç”¨ç‰¹æ®Šé¢œè‰²
                if (index === 4 || index === 8) { // æ‹‡æŒ‡å’Œé£ŸæŒ‡æŒ‡å°–
                    color = '#ff00ff'; // ç´«è‰²
                }
                
                canvasCtx.fillStyle = color;
                canvasCtx.beginPath();
                canvasCtx.arc(
                    landmark.x * canvasElement.width,
                    landmark.y * canvasElement.height,
                    3, 0, Math.PI * 2
                );
                canvasCtx.fill();
            });
            
            canvasCtx.restore();
            
            // ç»˜åˆ¶æ‰‹åŠ¿çŠ¶æ€
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            canvasCtx.fillRect(0, 0, canvasElement.width, 18);
            canvasCtx.fillStyle = '#ffffff';
            canvasCtx.font = '10px Arial';
            canvasCtx.textAlign = 'center';
            canvasCtx.fillText(getGestureText(STATE.hand.gesture), canvasElement.width / 2, 12);
        }

        function getGestureText(gesture) {
            switch (gesture) {
                case 'FIST': return 'âœŠ æ¡æ‹³';
                case 'OPEN': return 'ğŸ–ï¸ å¼ å¼€';
                case 'PINCH': return 'ğŸ¤ æåˆ';
                case 'ROTATE': return 'ğŸ”„ æ—‹è½¬';
                default: return 'ğŸ‘‹ ç­‰å¾…æ‰‹åŠ¿';
            }
        }

        function updateHandStatus(text) {
            const handStatus = document.getElementById('hand-status');
            const handText = document.getElementById('hand-text');
            
            if (handStatus && handText) {
                handText.textContent = text;
                
                if (!STATE.cameraEnabled) {
                    handStatus.style.opacity = '0.5';
                } else if (STATE.hand.detected) {
                    handStatus.style.opacity = '1';
                    handStatus.style.borderColor = 'rgba(212, 175, 55, 0.6)';
                } else {
                    handStatus.style.opacity = '0.7';
                }
            }
        }

        function updateStatusIndicator() {
            const indicator = document.getElementById('status-indicator');
            const modeText = document.getElementById('mode-text');
            const icon = indicator?.querySelector('.status-icon');
            
            if (indicator && modeText && icon) {
                switch (STATE.mode) {
                    case 'TREE':
                        modeText.textContent = 'åœ£è¯æ ‘å½¢æ€';
                        icon.textContent = 'ğŸ„';
                        indicator.style.borderColor = 'rgba(34, 139, 34, 0.6)';
                        break;
                    case 'SCATTER':
                        modeText.textContent = 'æ•£å¼€å½¢æ€';
                        icon.textContent = 'âœ¨';
                        indicator.style.borderColor = 'rgba(212, 175, 55, 0.6)';
                        break;
                    case 'FOCUS':
                        modeText.textContent = 'ç…§ç‰‡æ”¾å¤§';
                        icon.textContent = 'ğŸ“¸';
                        indicator.style.borderColor = 'rgba(66, 133, 244, 0.6)';
                        break;
                }
            }
        }

        function showDebugInfo(text) {
            const debugInfo = document.getElementById('debug-info');
            if (debugInfo) {
                debugInfo.textContent = text;
                debugInfo.style.display = 'block';
            }
        }

        function showCalibrationOverlay() {
            document.getElementById('calibration-overlay').style.display = 'flex';
        }

        function hideCalibrationOverlay() {
            document.getElementById('calibration-overlay').style.display = 'none';
        }

        function startCalibration() {
            const stepElement = document.getElementById('calibration-step');
            const progressElement = document.getElementById('calibration-progress');
            const startBtn = document.getElementById('start-calibration');
            
            startBtn.disabled = true;
            startBtn.textContent = 'æ ¡å‡†ä¸­...';
            
            stepElement.textContent = 'æ­¥éª¤1/3: è¯·æ¡ç´§æ‹³å¤´ï¼Œä¿æŒ3ç§’';
            progressElement.innerHTML = '';
            
            setTimeout(() => {
                stepElement.textContent = 'æ­¥éª¤2/3: è¯·å®Œå…¨å¼ å¼€æ‰‹æŒï¼Œä¿æŒ3ç§’';
                
                setTimeout(() => {
                    stepElement.textContent = 'æ­¥éª¤3/3: è¯·ç”¨æ‹‡æŒ‡å’Œé£ŸæŒ‡åšæåˆåŠ¨ä½œï¼Œä¿æŒ3ç§’';
                    
                    setTimeout(() => {
                        stepElement.textContent = 'æ ¡å‡†å®Œæˆï¼ç°åœ¨å¯ä»¥å¼€å§‹ä½¿ç”¨æ‰‹åŠ¿æ§åˆ¶';
                        progressElement.innerHTML = '<div style="color:#4ecdc4; margin-top:10px;">âœ“ æ ¡å‡†æˆåŠŸ</div>';
                        startBtn.textContent = 'æ ¡å‡†å®Œæˆ';
                        startBtn.disabled = false;
                        startBtn.onclick = () => {
                            hideCalibrationOverlay();
                            showDebugInfo('æ‰‹åŠ¿æ ¡å‡†å®Œæˆï¼Œå¯ä»¥å¼€å§‹ä½¿ç”¨');
                        };
                    }, 3000);
                }, 3000);
            }, 3000);
        }

        function skipCalibration() {
            hideCalibrationOverlay();
            showDebugInfo('è·³è¿‡æ ¡å‡†ï¼Œä½¿ç”¨é»˜è®¤æ‰‹åŠ¿è®¾ç½®');
        }

        // UIäº‹ä»¶å¤„ç†
        function setupUIEvents() {
            // æŒ‰é’®æ§åˆ¶
            document.getElementById('btn-tree').addEventListener('click', () => {
                STATE.mode = 'TREE';
                STATE.focusTarget = null;
                STATE.autoRotate = true;
                updateStatusIndicator();
                showDebugInfo('æ‰‹åŠ¨ï¼šåˆ‡æ¢åˆ°åœ£è¯æ ‘å½¢æ€');
            });
            
            document.getElementById('btn-scatter').addEventListener('click', () => {
                STATE.mode = 'SCATTER';
                STATE.focusTarget = null;
                STATE.autoRotate = false;
                updateStatusIndicator();
                showDebugInfo('æ‰‹åŠ¨ï¼šåˆ‡æ¢åˆ°æ•£å¼€å½¢æ€');
            });
            
            document.getElementById('btn-focus').addEventListener('click', () => {
                const photos = particleSystem.filter(p => p.type === 'PHOTO');
                if (photos.length > 0) {
                    STATE.mode = 'FOCUS';
                    const randomIndex = Math.floor(Math.random() * photos.length);
                    STATE.focusTarget = photos[randomIndex].mesh;
                    updateStatusIndicator();
                    showDebugInfo('æ‰‹åŠ¨ï¼šæ”¾å¤§éšæœºç…§ç‰‡');
                }
            });
            
            document.getElementById('btn-calibrate').addEventListener('click', () => {
                showCalibrationOverlay();
            });
            
            // æ ¡å‡†å¼€å§‹æŒ‰é’®
            document.getElementById('start-calibration').addEventListener('click', startCalibration);
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('orientationchange', () => {
                setTimeout(onWindowResize, 100);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Three.jsç²’å­ç³»ç»Ÿä»£ç ï¼ˆç®€åŒ–ç‰ˆï¼‰
        function createTextures() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0,0,32,32);
            ctx.fillStyle = '#880000'; 
            ctx.beginPath();
            for(let i=-32; i<64; i+=8) {
                ctx.moveTo(i, 0); 
                ctx.lineTo(i+8, 32); 
                ctx.lineTo(i+4, 32); 
                ctx.lineTo(i-4, 0);
            }
            ctx.fill();
            caneTexture = new THREE.CanvasTexture(canvas);
            caneTexture.wrapS = THREE.RepeatWrapping;
            caneTexture.wrapT = THREE.RepeatWrapping;
            caneTexture.repeat.set(1, 1);
        }

        class Particle {
            constructor(mesh, type, isDust = false) {
                this.mesh = mesh;
                this.type = type;
                this.isDust = isDust;
                
                this.posTree = new THREE.Vector3();
                this.posScatter = new THREE.Vector3();
                this.posFocus = new THREE.Vector3();
                this.baseScale = mesh.scale.x;

                this.spinSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * (type === 'PHOTO' ? 0.05 : 0.4),
                    (Math.random() - 0.5) * (type === 'PHOTO' ? 0.05 : 0.4),
                    (Math.random() - 0.5) * (type === 'PHOTO' ? 0.05 : 0.4)
                );

                this.calculatePositions();
            }

            calculatePositions() {
                // åœ£è¯æ ‘ä½ç½®
                const h = CONFIG.particles.treeHeight;
                const halfH = h / 2;
                let t = Math.random(); 
                t = Math.pow(t, 0.8); 
                const y = (t * h) - halfH;
                let rMax = CONFIG.particles.treeRadius * (1.0 - t); 
                if (rMax < 0.2) rMax = 0.2;
                const angle = t * 25 * Math.PI + Math.random() * Math.PI; 
                const r = rMax * (0.8 + Math.random() * 0.4); 
                this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);

                // æ•£å¼€ä½ç½®
                let rScatter = this.isDust ? (3 + Math.random()*6) : (2 + Math.random()*4);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(
                    rScatter * Math.sin(phi) * Math.cos(theta),
                    rScatter * Math.sin(phi) * Math.sin(theta),
                    rScatter * Math.cos(phi)
                );

                // ç„¦ç‚¹ä½ç½®ï¼ˆç…§ç‰‡æ”¾å¤§æ—¶ï¼Œå…¶ä»–ç…§ç‰‡çš„ä½ç½®ï¼‰
                const focusAngle = Math.random() * Math.PI * 2;
                const focusRadius = 10;
                this.posFocus.set(
                    Math.cos(focusAngle) * focusRadius,
                    (Math.random() - 0.5) * 8,
                    Math.sin(focusAngle) * focusRadius
                );
            }

            update(dt, mode, focusTargetMesh) {
                let targetPos = this.posTree;
                let targetScale = this.baseScale;
                let shouldLookAtCamera = false;

                if (mode === 'SCATTER') {
                    targetPos = this.posScatter;
                    targetScale = this.baseScale * 1.5;
                    
                    // åœ¨æ•£å¼€çŠ¶æ€ä¸‹æ·»åŠ æ—‹è½¬
                    this.mesh.rotation.x += this.spinSpeed.x * dt;
                    this.mesh.rotation.y += this.spinSpeed.y * dt;
                    this.mesh.rotation.z += this.spinSpeed.z * dt;
                } else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        // ç„¦ç‚¹ç…§ç‰‡ï¼šæ”¾å¤§åˆ°å±å¹•ä¸­å¤®
                        targetPos = new THREE.Vector3(0, 1, 8);
                        targetScale = this.baseScale * 5;
                        shouldLookAtCamera = true;
                    } else {
                        // å…¶ä»–ç…§ç‰‡ï¼šç§»åŠ¨åˆ°è¾¹ç¼˜
                        targetPos = this.posFocus;
                        targetScale = this.baseScale * 0.5;
                    }
                } else {
                    // TREE æ¨¡å¼
                    this.mesh.rotation.y += 0.1 * dt;
                }

                // å¹³æ»‘è¿‡æ¸¡
                const lerpSpeed = mode === 'FOCUS' && this.mesh === focusTargetMesh ? 6.0 : 2.0;
                this.mesh.position.lerp(targetPos, lerpSpeed * dt);
                this.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), lerpSpeed * dt);

                if (shouldLookAtCamera) {
                    this.mesh.lookAt(camera.position);
                }

                // ç°å°˜ç²’å­åœ¨åœ£è¯æ ‘æ¨¡å¼ä¸‹éšè—
                if (this.isDust && mode === 'TREE') {
                    this.mesh.visible = false;
                } else if (this.isDust) {
                    this.mesh.visible = true;
                    // ç°å°˜çš„è„‰åŠ¨æ•ˆæœ
                    const pulseScale = 0.8 + 0.4 * Math.sin(clock.elapsedTime * 3 + this.mesh.id);
                    this.mesh.scale.multiplyScalar(pulseScale);
                }
            }
        }

        function createParticles() {
            const sphereGeo = new THREE.SphereGeometry(0.2, 6, 6);
            const boxGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
            
            const goldMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.champagneGold,
                metalness: 0.6,
                roughness: 0.5
            });

            const greenMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.deepGreen,
                roughness: 0.9
            });

            const redMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.accentRed,
                roughness: 0.6
            });
            
            const candyMat = new THREE.MeshStandardMaterial({ 
                map: caneTexture,
                roughness: 0.8
            });

            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random();
                let mesh, type;
                
                if (rand < 0.40) {
                    mesh = new THREE.Mesh(boxGeo, greenMat);
                    type = 'BOX';
                } else if (rand < 0.70) {
                    mesh = new THREE.Mesh(boxGeo, goldMat);
                    type = 'GOLD_BOX';
                } else if (rand < 0.90) {
                    mesh = new THREE.Mesh(sphereGeo, goldMat);
                    type = 'GOLD_SPHERE';
                } else if (rand < 0.95) {
                    mesh = new THREE.Mesh(sphereGeo, redMat);
                    type = 'RED';
                } else {
                    mesh = new THREE.Mesh(sphereGeo, candyMat);
                    type = 'CANDY';
                }

                const s = 0.1 + Math.random() * 0.2;
                mesh.scale.set(s, s, s);
                mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);
                
                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, type, false));
            }

            // æ·»åŠ æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(0.5, 0);
            const starMat = new THREE.MeshStandardMaterial({
                color: 0xffdd88,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.particles.treeHeight / 2 + 0.5, 0);
            mainGroup.add(star);
            
            mainGroup.add(photoMeshGroup);
        }

        function createDust() {
            const geo = new THREE.TetrahedronGeometry(0.02, 0);
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0xffeebb,
                transparent: true,
                opacity: 0.3
            });
            
            for(let i = 0; i < CONFIG.particles.dustCount; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.scale.setScalar(0.1 + Math.random());
                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, 'DUST', true));
            }
        }

        function createDefaultPhotos() {
            const defaultPhotos = [
                { text: "åœ£è¯\nå¿«ä¹", color: "#d4af37" },
                { text: "å¹³å®‰\nå–œä¹", color: "#ff6b6b" },
                { text: "å¿ƒæƒ³\näº‹æˆ", color: "#4ecdc4" }
            ];
            
            defaultPhotos.forEach((photo, index) => {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // èƒŒæ™¯
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, 256, 256);
                
                // è¾¹æ¡†
                ctx.strokeStyle = photo.color;
                ctx.lineWidth = 6;
                ctx.strokeRect(10, 10, 236, 236);
                
                // æ–‡å­—
                ctx.fillStyle = photo.color;
                ctx.font = 'bold 32px "Microsoft YaHei", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const lines = photo.text.split('\n');
                lines.forEach((line, i) => {
                    ctx.fillText(line, 128, 128 - 20 + (i * 40));
                });
                
                const tex = new THREE.CanvasTexture(canvas);
                tex.colorSpace = THREE.SRGBColorSpace;
                addPhotoToScene(tex);
            });
        }

        function addPhotoToScene(texture) {
            const frameGeo = new THREE.BoxGeometry(0.9, 1.2, 0.02);
            const frameMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.champagneGold,
                metalness: 0.6,
                roughness: 0.5
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);

            const photoGeo = new THREE.PlaneGeometry(0.8, 1.1);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.015;

            const group = new THREE.Group();
            group.add(frame);
            group.add(photo);
            
            const s = 0.4;
            group.scale.set(s, s, s);
            
            photoMeshGroup.add(group);
            particleSystem.push(new Particle(group, 'PHOTO', false));
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.033);
            
            // è‡ªåŠ¨æ—‹è½¬ï¼ˆä»…åœ¨åœ£è¯æ ‘æ¨¡å¼ä¸‹ï¼‰
            if (STATE.autoRotate && STATE.mode === 'TREE') {
                STATE.rotation.y += 0.1 * dt;
            }
            
            // åº”ç”¨æ—‹è½¬
            mainGroup.rotation.x = STATE.rotation.x;
            mainGroup.rotation.y = STATE.rotation.y;
            
            // æ›´æ–°ç²’å­
            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));
            
            // æ¸²æŸ“
            if (composer && !isMobile) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            setTimeout(init, 100);
        });
        
        // è®¾ç½®åŠ è½½è¶…æ—¶
        setTimeout(() => {
            const loader = document.getElementById('loader');
            if (loader && loader.style.display !== 'none') {
                showDebugInfo('åŠ è½½æ—¶é—´è¿‡é•¿ï¼Œè¯·ç¡®ä¿ç½‘ç»œè¿æ¥æ­£å¸¸');
            }
        }, 10000);
    </script>
</body>
</html>
